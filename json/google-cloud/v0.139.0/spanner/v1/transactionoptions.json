{"id":"spanner\/v1\/transactionoptions","type":"","title":"Google\\Cloud\\Spanner\\V1\\TransactionOptions","name":"TransactionOptions","description":"<h1>Transactions<\/h1>\n<p>Each session can have at most one active transaction at a time. After the\nactive transaction is completed, the session can immediately be\nre-used for the next transaction. It is not necessary to create a\nnew session for each transaction.<\/p>\n<h1>Transaction Modes<\/h1>\n<p>Cloud Spanner supports three transaction modes:<\/p>\n<ol>\n<li>Locking read-write. This type of transaction is the only way\nto write data into Cloud Spanner. These transactions rely on\npessimistic locking and, if necessary, two-phase commit.\nLocking read-write transactions may abort, requiring the\napplication to retry.<\/li>\n<li>Snapshot read-only. This transaction type provides guaranteed\nconsistency across several reads, but does not allow\nwrites. Snapshot read-only transactions can be configured to\nread at timestamps in the past. Snapshot read-only\ntransactions do not need to be committed.<\/li>\n<li>Partitioned DML. This type of transaction is used to execute\na single Partitioned DML statement. Partitioned DML partitions\nthe key space and runs the DML statement over each partition\nin parallel using separate, internal transactions that commit\nindependently. Partitioned DML transactions do not need to be\ncommitted.\nFor transactions that only read, snapshot read-only transactions\nprovide simpler semantics and are almost always faster. In\nparticular, read-only transactions do not take locks, so they do\nnot conflict with read-write transactions. As a consequence of not\ntaking locks, they also do not abort, so retry loops are not needed.\nTransactions may only read\/write data in a single database. They\nmay, however, read\/write data in different tables within that\ndatabase.\n<h2>Locking Read-Write Transactions<\/h2>\n<p>Locking transactions may be used to atomically read-modify-write\ndata anywhere in a database. This type of transaction is externally\nconsistent.\nClients should attempt to minimize the amount of time a transaction\nis active. Faster transactions commit with higher probability\nand cause less contention. Cloud Spanner attempts to keep read locks\nactive as long as the transaction continues to do reads, and the\ntransaction has not been terminated by\n[Commit][google.spanner.v1.Spanner.Commit] or\n[Rollback][google.spanner.v1.Spanner.Rollback].  Long periods of\ninactivity at the client may cause Cloud Spanner to release a\ntransaction's locks and abort it.\nConceptually, a read-write transaction consists of zero or more\nreads or SQL statements followed by\n[Commit][google.spanner.v1.Spanner.Commit]. At any time before\n[Commit][google.spanner.v1.Spanner.Commit], the client can send a\n[Rollback][google.spanner.v1.Spanner.Rollback] request to abort the\ntransaction.<\/p>\n<h3>Semantics<\/h3>\n<p>Cloud Spanner can commit the transaction if all read locks it acquired\nare still valid at commit time, and it is able to acquire write\nlocks for all writes. Cloud Spanner can abort the transaction for any\nreason. If a commit attempt returns <code>ABORTED<\/code>, Cloud Spanner guarantees\nthat the transaction has not modified any user data in Cloud Spanner.\nUnless the transaction commits, Cloud Spanner makes no guarantees about\nhow long the transaction's locks were held for. It is an error to\nuse Cloud Spanner locks for any sort of mutual exclusion other than\nbetween Cloud Spanner transactions themselves.<\/p>\n<h3>Retrying Aborted Transactions<\/h3>\n<p>When a transaction aborts, the application can choose to retry the\nwhole transaction again. To maximize the chances of successfully\ncommitting the retry, the client should execute the retry in the\nsame session as the original attempt. The original session's lock\npriority increases with each consecutive abort, meaning that each\nattempt has a slightly better chance of success than the previous.\nUnder some circumstances (e.g., many transactions attempting to\nmodify the same row(s)), a transaction can abort many times in a\nshort period before successfully committing. Thus, it is not a good\nidea to cap the number of retries a transaction can attempt;\ninstead, it is better to limit the total amount of wall time spent\nretrying.<\/p>\n<h3>Idle Transactions<\/h3>\n<p>A transaction is considered idle if it has no outstanding reads or\nSQL queries and has not started a read or SQL query within the last 10\nseconds. Idle transactions can be aborted by Cloud Spanner so that they\ndon't hold on to locks indefinitely. In that case, the commit will\nfail with error <code>ABORTED<\/code>.\nIf this behavior is undesirable, periodically executing a simple\nSQL query in the transaction (e.g., <code>SELECT 1<\/code>) prevents the\ntransaction from becoming idle.<\/p>\n<h2>Snapshot Read-Only Transactions<\/h2>\n<p>Snapshot read-only transactions provides a simpler method than\nlocking read-write transactions for doing several consistent\nreads. However, this type of transaction does not support writes.\nSnapshot transactions do not take locks. Instead, they work by\nchoosing a Cloud Spanner timestamp, then executing all reads at that\ntimestamp. Since they do not acquire locks, they do not block\nconcurrent read-write transactions.\nUnlike locking read-write transactions, snapshot read-only\ntransactions never abort. They can fail if the chosen read\ntimestamp is garbage collected; however, the default garbage\ncollection policy is generous enough that most applications do not\nneed to worry about this in practice.\nSnapshot read-only transactions do not need to call\n[Commit][google.spanner.v1.Spanner.Commit] or\n[Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not\npermitted to do so).\nTo execute a snapshot transaction, the client specifies a timestamp\nbound, which tells Cloud Spanner how to choose a read timestamp.\nThe types of timestamp bound are:<\/p>\n<ul>\n<li>Strong (the default).<\/li>\n<li>Bounded staleness.<\/li>\n<li>Exact staleness.\nIf the Cloud Spanner database to be read is geographically distributed,\nstale read-only transactions can execute more quickly than strong\nor read-write transaction, because they are able to execute far\nfrom the leader replica.\nEach type of timestamp bound is discussed in detail below.\n<h3>Strong<\/h3>\n<p>Strong reads are guaranteed to see the effects of all transactions\nthat have committed before the start of the read. Furthermore, all\nrows yielded by a single read are consistent with each other -- if\nany part of the read observes a transaction, all parts of the read\nsee the transaction.\nStrong reads are not repeatable: two consecutive strong read-only\ntransactions might return inconsistent results if there are\nconcurrent writes. If consistency across reads is required, the\nreads should be executed within a transaction or at an exact read\ntimestamp.\nSee [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].<\/p>\n<h3>Exact Staleness<\/h3>\n<p>These timestamp bounds execute reads at a user-specified\ntimestamp. Reads at a timestamp are guaranteed to see a consistent\nprefix of the global transaction history: they observe\nmodifications done by all transactions with a commit timestamp &lt;=\nthe read timestamp, and observe none of the modifications done by\ntransactions with a larger commit timestamp. They will block until\nall conflicting transactions that may be assigned commit timestamps\n&lt;= the read timestamp have finished.\nThe timestamp can either be expressed as an absolute Cloud Spanner commit\ntimestamp or a staleness relative to the current time.\nThese modes do not require a &quot;negotiation phase&quot; to pick a\ntimestamp. As a result, they execute slightly faster than the\nequivalent boundedly stale concurrency modes. On the other hand,\nboundedly stale reads usually return fresher results.\nSee [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and\n[TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].<\/p>\n<h3>Bounded Staleness<\/h3>\n<p>Bounded staleness modes allow Cloud Spanner to pick the read timestamp,\nsubject to a user-provided staleness bound. Cloud Spanner chooses the\nnewest timestamp within the staleness bound that allows execution\nof the reads at the closest available replica without blocking.\nAll rows yielded are consistent with each other -- if any part of\nthe read observes a transaction, all parts of the read see the\ntransaction. Boundedly stale reads are not repeatable: two stale\nreads, even if they use the same staleness bound, can execute at\ndifferent timestamps and thus return inconsistent results.\nBoundedly stale reads execute in two phases: the first phase\nnegotiates a timestamp among all replicas needed to serve the\nread. In the second phase, reads are executed at the negotiated\ntimestamp.\nAs a result of the two phase execution, bounded staleness reads are\nusually a little slower than comparable exact staleness\nreads. However, they are typically able to return fresher\nresults, and are more likely to execute at the closest replica.\nBecause the timestamp negotiation requires up-front knowledge of\nwhich rows will be read, it can only be used with single-use\nread-only transactions.\nSee [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and\n[TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].<\/p>\n<h3>Old Read Timestamps and Garbage Collection<\/h3>\n<p>Cloud Spanner continuously garbage collects deleted and overwritten data\nin the background to reclaim storage space. This process is known\nas &quot;version GC&quot;. By default, version GC reclaims versions after they\nare one hour old. Because of this, Cloud Spanner cannot perform reads\nat read timestamps more than one hour in the past. This\nrestriction also applies to in-progress reads and\/or SQL queries whose\ntimestamp become too old while executing. Reads and SQL queries with\ntoo-old read timestamps fail with the error <code>FAILED_PRECONDITION<\/code>.<\/p>\n<h2>Partitioned DML Transactions<\/h2>\n<p>Partitioned DML transactions are used to execute DML statements with a\ndifferent execution strategy that provides different, and often better,\nscalability properties for large, table-wide operations than DML in a\nReadWrite transaction. Smaller scoped statements, such as an OLTP workload,\nshould prefer using ReadWrite transactions.\nPartitioned DML partitions the keyspace and runs the DML statement on each\npartition in separate, internal transactions. These transactions commit\nautomatically when complete, and run independently from one another.\nTo reduce lock contention, this execution strategy only acquires read locks\non rows that match the WHERE clause of the statement. Additionally, the\nsmaller per-partition transactions hold locks for less time.\nThat said, Partitioned DML is not a drop-in replacement for standard DML used\nin ReadWrite transactions.<\/p><\/li>\n<li>The DML statement must be fully-partitionable. Specifically, the statement\nmust be expressible as the union of many statements which each access only\na single row of the table.<\/li>\n<li>The statement is not applied atomically to all rows of the table. Rather,\nthe statement is applied atomically to partitions of the table, in\nindependent transactions. Secondary index rows are updated atomically\nwith the base table rows.<\/li>\n<li>Partitioned DML does not guarantee exactly-once execution semantics\nagainst a partition. The statement will be applied at least once to each\npartition. It is strongly recommended that the DML statement should be\nidempotent to avoid unexpected results. For instance, it is potentially\ndangerous to run a statement such as\n<code>UPDATE table SET column = column + 1<\/code> as it could be run multiple times\nagainst some rows.<\/li>\n<li>The partitions are committed automatically - there is no support for\nCommit or Rollback. If the call returns an error, or if the client issuing\nthe ExecuteSql call dies, it is possible that some rows had the statement\nexecuted on them successfully. It is also possible that statement was\nnever executed against other rows.<\/li>\n<li>Partitioned DML transactions may only contain the execution of a single\nDML statement via ExecuteSql or ExecuteStreamingSql.<\/li>\n<li>If any error is encountered during the execution of the partitioned DML\noperation (for instance, a UNIQUE INDEX violation, division by zero, or a\nvalue that cannot be stored due to schema constraints), then the\noperation is stopped at that point and an error is returned. It is\npossible that at this point, some partitions have been committed (or even\ncommitted multiple times), and other partitions have not been run at all.\nGiven the above, Partitioned DML is good fit for large, database-wide,\noperations that are idempotent, such as deleting old rows from a very large\ntable.<\/li>\n<\/ul><\/li>\n<\/ol>\n<p>Generated from protobuf message <code>google.spanner.v1.TransactionOptions<\/code><\/p>\n<p>Extends <a href=\"https:\/\/github.com\/protocolbuffers\/protobuf-php\/tree\/v3.13.0\/src\/Google\/Protobuf\/Internal\/Message.php\" target=\"_blank\">Google\\Protobuf\\Internal\\Message<\/a><\/p>","examples":[],"resources":[],"methods":[{"id":"__construct","type":"constructor","name":"__construct","source":"Spanner\/src\/V1\/TransactionOptions.php#L257","description":"<p>Constructor.<\/p>","examples":[],"resources":[],"params":[{"name":"data","description":"<p>Optional. Data for populating the Message object.<\/p>","types":["<a href=\"http:\/\/php.net\/manual\/en\/language.types.array.php\" target=\"_blank\">array<\/a>"],"optional":false,"nullable":null},{"name":"data.read_write\n","description":"<p>Transaction may write. Authorization to begin a read-write transaction requires <code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission on the <code>session<\/code> resource.<\/p>","types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/readwrite\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadWrite<\/a>"],"optional":null,"nullable":null},{"name":"data.partitioned_dml\n","description":"<p>Partitioned DML transaction. Authorization to begin a Partitioned DML transaction requires <code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission on the <code>session<\/code> resource.<\/p>","types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/partitioneddml\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PartitionedDml<\/a>"],"optional":null,"nullable":null},{"name":"data.read_only\n","description":"<p>Transaction will not write. Authorization to begin a read-only transaction requires <code>spanner.databases.beginReadOnlyTransaction<\/code> permission on the <code>session<\/code> resource.<\/p>","types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/readonly\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadOnly<\/a>"],"optional":null,"nullable":null}],"exceptions":[],"returns":[]},{"id":"getReadWrite","type":"instance","name":"getReadWrite","source":"Spanner\/src\/V1\/TransactionOptions.php#L271","description":"<p>Transaction may write.<\/p>\n<p>Authorization to begin a read-write transaction requires\n<code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;<\/code><\/p>","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/readwrite\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadWrite<\/a>"],"description":""}]},{"id":"setReadWrite","type":"instance","name":"setReadWrite","source":"Spanner\/src\/V1\/TransactionOptions.php#L291","description":"<p>Transaction may write.<\/p>\n<p>Authorization to begin a read-write transaction requires\n<code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;<\/code><\/p>","examples":[],"resources":[],"params":[{"name":"var","description":"<p>Transaction may write.<\/p>\n<p>Authorization to begin a read-write transaction requires\n<code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n","types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/readwrite\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadWrite<\/a>"],"optional":false,"nullable":null}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\">Google\\Cloud\\Spanner\\V1\\TransactionOptions<\/a>"],"description":""}]},{"id":"getPartitionedDml","type":"instance","name":"getPartitionedDml","source":"Spanner\/src\/V1\/TransactionOptions.php#L308","description":"<p>Partitioned DML transaction.<\/p>\n<p>Authorization to begin a Partitioned DML transaction requires\n<code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;<\/code><\/p>","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/partitioneddml\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PartitionedDml<\/a>"],"description":""}]},{"id":"setPartitionedDml","type":"instance","name":"setPartitionedDml","source":"Spanner\/src\/V1\/TransactionOptions.php#L328","description":"<p>Partitioned DML transaction.<\/p>\n<p>Authorization to begin a Partitioned DML transaction requires\n<code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;<\/code><\/p>","examples":[],"resources":[],"params":[{"name":"var","description":"<p>Partitioned DML transaction.<\/p>\n<p>Authorization to begin a Partitioned DML transaction requires\n<code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n","types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/partitioneddml\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PartitionedDml<\/a>"],"optional":false,"nullable":null}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\">Google\\Cloud\\Spanner\\V1\\TransactionOptions<\/a>"],"description":""}]},{"id":"getReadOnly","type":"instance","name":"getReadOnly","source":"Spanner\/src\/V1\/TransactionOptions.php#L345","description":"<p>Transaction will not write.<\/p>\n<p>Authorization to begin a read-only transaction requires\n<code>spanner.databases.beginReadOnlyTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;<\/code><\/p>","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/readonly\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadOnly<\/a>"],"description":""}]},{"id":"setReadOnly","type":"instance","name":"setReadOnly","source":"Spanner\/src\/V1\/TransactionOptions.php#L365","description":"<p>Transaction will not write.<\/p>\n<p>Authorization to begin a read-only transaction requires\n<code>spanner.databases.beginReadOnlyTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;<\/code><\/p>","examples":[],"resources":[],"params":[{"name":"var","description":"<p>Transaction will not write.<\/p>\n<p>Authorization to begin a read-only transaction requires\n<code>spanner.databases.beginReadOnlyTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n","types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\/readonly\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadOnly<\/a>"],"optional":false,"nullable":null}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"spanner\/v1\/transactionoptions\">Google\\Cloud\\Spanner\\V1\\TransactionOptions<\/a>"],"description":""}]},{"id":"getMode","type":"instance","name":"getMode","source":"Spanner\/src\/V1\/TransactionOptions.php#L376","description":"","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a href=\"http:\/\/php.net\/manual\/en\/language.types.string.php\" target=\"_blank\">string<\/a>"],"description":""}]}]}