<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/monitoring/v3/uptime.proto

namespace Google\Cloud\Monitoring\V3\UptimeCheckConfig;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Information involved in an HTTP/HTTPS Uptime check request.
 *
 * Generated from protobuf message <code>google.monitoring.v3.UptimeCheckConfig.HttpCheck</code>
 */
class HttpCheck extends \Google\Protobuf\Internal\Message
{
    /**
     * The HTTP request method to use for the check. If set to
     * `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;</code>
     */
    private $request_method = 0;
    /**
     * If `true`, use HTTPS instead of HTTP to run the check.
     *
     * Generated from protobuf field <code>bool use_ssl = 1;</code>
     */
    private $use_ssl = false;
    /**
     * Optional (defaults to "/"). The path to the page against which to run
     * the check. Will be combined with the `host` (specified within the
     * `monitored_resource`) and `port` to construct the full URL. If the
     * provided path does not begin with "/", a "/" will be prepended
     * automatically.
     *
     * Generated from protobuf field <code>string path = 2;</code>
     */
    private $path = '';
    /**
     * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
     * `use_ssl` is `true`). The TCP port on the HTTP server against which to
     * run the check. Will be combined with host (specified within the
     * `monitored_resource`) and `path` to construct the full URL.
     *
     * Generated from protobuf field <code>int32 port = 3;</code>
     */
    private $port = 0;
    /**
     * The authentication information. Optional when creating an HTTP check;
     * defaults to empty.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;</code>
     */
    private $auth_info = null;
    /**
     * Boolean specifying whether to encrypt the header information.
     * Encryption should be specified for any headers related to authentication
     * that you do not wish to be seen when retrieving the configuration. The
     * server will be responsible for encrypting the headers.
     * On Get/List calls, if `mask_headers` is set to `true` then the headers
     * will be obscured with `******.`
     *
     * Generated from protobuf field <code>bool mask_headers = 5;</code>
     */
    private $mask_headers = false;
    /**
     * The list of headers to send as part of the Uptime check request.
     * If two headers have the same key and different values, they should
     * be entered as a single header, with the value being a comma-separated
     * list of all the desired values as described at
     * https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
     * Entering two separate headers with the same key in a Create call will
     * cause the first to be overwritten by the second.
     * The maximum number of headers allowed is 100.
     *
     * Generated from protobuf field <code>map<string, string> headers = 6;</code>
     */
    private $headers;
    /**
     * The content type header to use for the check. The following
     * configurations result in errors:
     * 1. Content type is specified in both the `headers` field and the
     * `content_type` field.
     * 2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
     * 3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
     * 4. Request method is `POST` and a "Content-Type" header is provided via
     * `headers` field. The `content_type` field should be used instead.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;</code>
     */
    private $content_type = 0;
    /**
     * Boolean specifying whether to include SSL certificate validation as a
     * part of the Uptime check. Only applies to checks where
     * `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
     * setting `validate_ssl` to `true` has no effect.
     *
     * Generated from protobuf field <code>bool validate_ssl = 7;</code>
     */
    private $validate_ssl = false;
    /**
     * The request body associated with the HTTP POST request. If `content_type`
     * is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
     * provide a `Content-Length` header via the `headers` field or the API will
     * do so. If the `request_method` is `GET` and `body` is not empty, the API
     * will return an error. The maximum byte size is 1 megabyte. Note: As with
     * all `bytes` fields, JSON representations are base64 encoded. e.g.:
     * "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is
     * "Zm9vJTI1M0RiYXI=".
     *
     * Generated from protobuf field <code>bytes body = 10;</code>
     */
    private $body = '';

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int $request_method
     *           The HTTP request method to use for the check. If set to
     *           `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
     *     @type bool $use_ssl
     *           If `true`, use HTTPS instead of HTTP to run the check.
     *     @type string $path
     *           Optional (defaults to "/"). The path to the page against which to run
     *           the check. Will be combined with the `host` (specified within the
     *           `monitored_resource`) and `port` to construct the full URL. If the
     *           provided path does not begin with "/", a "/" will be prepended
     *           automatically.
     *     @type int $port
     *           Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
     *           `use_ssl` is `true`). The TCP port on the HTTP server against which to
     *           run the check. Will be combined with host (specified within the
     *           `monitored_resource`) and `path` to construct the full URL.
     *     @type \Google\Cloud\Monitoring\V3\UptimeCheckConfig\HttpCheck\BasicAuthentication $auth_info
     *           The authentication information. Optional when creating an HTTP check;
     *           defaults to empty.
     *     @type bool $mask_headers
     *           Boolean specifying whether to encrypt the header information.
     *           Encryption should be specified for any headers related to authentication
     *           that you do not wish to be seen when retrieving the configuration. The
     *           server will be responsible for encrypting the headers.
     *           On Get/List calls, if `mask_headers` is set to `true` then the headers
     *           will be obscured with `******.`
     *     @type array|\Google\Protobuf\Internal\MapField $headers
     *           The list of headers to send as part of the Uptime check request.
     *           If two headers have the same key and different values, they should
     *           be entered as a single header, with the value being a comma-separated
     *           list of all the desired values as described at
     *           https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
     *           Entering two separate headers with the same key in a Create call will
     *           cause the first to be overwritten by the second.
     *           The maximum number of headers allowed is 100.
     *     @type int $content_type
     *           The content type header to use for the check. The following
     *           configurations result in errors:
     *           1. Content type is specified in both the `headers` field and the
     *           `content_type` field.
     *           2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
     *           3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
     *           4. Request method is `POST` and a "Content-Type" header is provided via
     *           `headers` field. The `content_type` field should be used instead.
     *     @type bool $validate_ssl
     *           Boolean specifying whether to include SSL certificate validation as a
     *           part of the Uptime check. Only applies to checks where
     *           `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
     *           setting `validate_ssl` to `true` has no effect.
     *     @type string $body
     *           The request body associated with the HTTP POST request. If `content_type`
     *           is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
     *           provide a `Content-Length` header via the `headers` field or the API will
     *           do so. If the `request_method` is `GET` and `body` is not empty, the API
     *           will return an error. The maximum byte size is 1 megabyte. Note: As with
     *           all `bytes` fields, JSON representations are base64 encoded. e.g.:
     *           "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is
     *           "Zm9vJTI1M0RiYXI=".
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Google\Monitoring\V3\Uptime::initOnce();
        parent::__construct($data);
    }

    /**
     * The HTTP request method to use for the check. If set to
     * `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;</code>
     * @return int
     */
    public function getRequestMethod()
    {
        return $this->request_method;
    }

    /**
     * The HTTP request method to use for the check. If set to
     * `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setRequestMethod($var)
    {
        GPBUtil::checkEnum($var, \Google\Cloud\Monitoring\V3\UptimeCheckConfig\HttpCheck\RequestMethod::class);
        $this->request_method = $var;

        return $this;
    }

    /**
     * If `true`, use HTTPS instead of HTTP to run the check.
     *
     * Generated from protobuf field <code>bool use_ssl = 1;</code>
     * @return bool
     */
    public function getUseSsl()
    {
        return $this->use_ssl;
    }

    /**
     * If `true`, use HTTPS instead of HTTP to run the check.
     *
     * Generated from protobuf field <code>bool use_ssl = 1;</code>
     * @param bool $var
     * @return $this
     */
    public function setUseSsl($var)
    {
        GPBUtil::checkBool($var);
        $this->use_ssl = $var;

        return $this;
    }

    /**
     * Optional (defaults to "/"). The path to the page against which to run
     * the check. Will be combined with the `host` (specified within the
     * `monitored_resource`) and `port` to construct the full URL. If the
     * provided path does not begin with "/", a "/" will be prepended
     * automatically.
     *
     * Generated from protobuf field <code>string path = 2;</code>
     * @return string
     */
    public function getPath()
    {
        return $this->path;
    }

    /**
     * Optional (defaults to "/"). The path to the page against which to run
     * the check. Will be combined with the `host` (specified within the
     * `monitored_resource`) and `port` to construct the full URL. If the
     * provided path does not begin with "/", a "/" will be prepended
     * automatically.
     *
     * Generated from protobuf field <code>string path = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setPath($var)
    {
        GPBUtil::checkString($var, True);
        $this->path = $var;

        return $this;
    }

    /**
     * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
     * `use_ssl` is `true`). The TCP port on the HTTP server against which to
     * run the check. Will be combined with host (specified within the
     * `monitored_resource`) and `path` to construct the full URL.
     *
     * Generated from protobuf field <code>int32 port = 3;</code>
     * @return int
     */
    public function getPort()
    {
        return $this->port;
    }

    /**
     * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
     * `use_ssl` is `true`). The TCP port on the HTTP server against which to
     * run the check. Will be combined with host (specified within the
     * `monitored_resource`) and `path` to construct the full URL.
     *
     * Generated from protobuf field <code>int32 port = 3;</code>
     * @param int $var
     * @return $this
     */
    public function setPort($var)
    {
        GPBUtil::checkInt32($var);
        $this->port = $var;

        return $this;
    }

    /**
     * The authentication information. Optional when creating an HTTP check;
     * defaults to empty.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;</code>
     * @return \Google\Cloud\Monitoring\V3\UptimeCheckConfig\HttpCheck\BasicAuthentication|null
     */
    public function getAuthInfo()
    {
        return $this->auth_info;
    }

    public function hasAuthInfo()
    {
        return isset($this->auth_info);
    }

    public function clearAuthInfo()
    {
        unset($this->auth_info);
    }

    /**
     * The authentication information. Optional when creating an HTTP check;
     * defaults to empty.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;</code>
     * @param \Google\Cloud\Monitoring\V3\UptimeCheckConfig\HttpCheck\BasicAuthentication $var
     * @return $this
     */
    public function setAuthInfo($var)
    {
        GPBUtil::checkMessage($var, \Google\Cloud\Monitoring\V3\UptimeCheckConfig\HttpCheck\BasicAuthentication::class);
        $this->auth_info = $var;

        return $this;
    }

    /**
     * Boolean specifying whether to encrypt the header information.
     * Encryption should be specified for any headers related to authentication
     * that you do not wish to be seen when retrieving the configuration. The
     * server will be responsible for encrypting the headers.
     * On Get/List calls, if `mask_headers` is set to `true` then the headers
     * will be obscured with `******.`
     *
     * Generated from protobuf field <code>bool mask_headers = 5;</code>
     * @return bool
     */
    public function getMaskHeaders()
    {
        return $this->mask_headers;
    }

    /**
     * Boolean specifying whether to encrypt the header information.
     * Encryption should be specified for any headers related to authentication
     * that you do not wish to be seen when retrieving the configuration. The
     * server will be responsible for encrypting the headers.
     * On Get/List calls, if `mask_headers` is set to `true` then the headers
     * will be obscured with `******.`
     *
     * Generated from protobuf field <code>bool mask_headers = 5;</code>
     * @param bool $var
     * @return $this
     */
    public function setMaskHeaders($var)
    {
        GPBUtil::checkBool($var);
        $this->mask_headers = $var;

        return $this;
    }

    /**
     * The list of headers to send as part of the Uptime check request.
     * If two headers have the same key and different values, they should
     * be entered as a single header, with the value being a comma-separated
     * list of all the desired values as described at
     * https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
     * Entering two separate headers with the same key in a Create call will
     * cause the first to be overwritten by the second.
     * The maximum number of headers allowed is 100.
     *
     * Generated from protobuf field <code>map<string, string> headers = 6;</code>
     * @return \Google\Protobuf\Internal\MapField
     */
    public function getHeaders()
    {
        return $this->headers;
    }

    /**
     * The list of headers to send as part of the Uptime check request.
     * If two headers have the same key and different values, they should
     * be entered as a single header, with the value being a comma-separated
     * list of all the desired values as described at
     * https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
     * Entering two separate headers with the same key in a Create call will
     * cause the first to be overwritten by the second.
     * The maximum number of headers allowed is 100.
     *
     * Generated from protobuf field <code>map<string, string> headers = 6;</code>
     * @param array|\Google\Protobuf\Internal\MapField $var
     * @return $this
     */
    public function setHeaders($var)
    {
        $arr = GPBUtil::checkMapField($var, \Google\Protobuf\Internal\GPBType::STRING, \Google\Protobuf\Internal\GPBType::STRING);
        $this->headers = $arr;

        return $this;
    }

    /**
     * The content type header to use for the check. The following
     * configurations result in errors:
     * 1. Content type is specified in both the `headers` field and the
     * `content_type` field.
     * 2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
     * 3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
     * 4. Request method is `POST` and a "Content-Type" header is provided via
     * `headers` field. The `content_type` field should be used instead.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;</code>
     * @return int
     */
    public function getContentType()
    {
        return $this->content_type;
    }

    /**
     * The content type header to use for the check. The following
     * configurations result in errors:
     * 1. Content type is specified in both the `headers` field and the
     * `content_type` field.
     * 2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
     * 3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
     * 4. Request method is `POST` and a "Content-Type" header is provided via
     * `headers` field. The `content_type` field should be used instead.
     *
     * Generated from protobuf field <code>.google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;</code>
     * @param int $var
     * @return $this
     */
    public function setContentType($var)
    {
        GPBUtil::checkEnum($var, \Google\Cloud\Monitoring\V3\UptimeCheckConfig\HttpCheck\ContentType::class);
        $this->content_type = $var;

        return $this;
    }

    /**
     * Boolean specifying whether to include SSL certificate validation as a
     * part of the Uptime check. Only applies to checks where
     * `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
     * setting `validate_ssl` to `true` has no effect.
     *
     * Generated from protobuf field <code>bool validate_ssl = 7;</code>
     * @return bool
     */
    public function getValidateSsl()
    {
        return $this->validate_ssl;
    }

    /**
     * Boolean specifying whether to include SSL certificate validation as a
     * part of the Uptime check. Only applies to checks where
     * `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
     * setting `validate_ssl` to `true` has no effect.
     *
     * Generated from protobuf field <code>bool validate_ssl = 7;</code>
     * @param bool $var
     * @return $this
     */
    public function setValidateSsl($var)
    {
        GPBUtil::checkBool($var);
        $this->validate_ssl = $var;

        return $this;
    }

    /**
     * The request body associated with the HTTP POST request. If `content_type`
     * is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
     * provide a `Content-Length` header via the `headers` field or the API will
     * do so. If the `request_method` is `GET` and `body` is not empty, the API
     * will return an error. The maximum byte size is 1 megabyte. Note: As with
     * all `bytes` fields, JSON representations are base64 encoded. e.g.:
     * "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is
     * "Zm9vJTI1M0RiYXI=".
     *
     * Generated from protobuf field <code>bytes body = 10;</code>
     * @return string
     */
    public function getBody()
    {
        return $this->body;
    }

    /**
     * The request body associated with the HTTP POST request. If `content_type`
     * is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
     * provide a `Content-Length` header via the `headers` field or the API will
     * do so. If the `request_method` is `GET` and `body` is not empty, the API
     * will return an error. The maximum byte size is 1 megabyte. Note: As with
     * all `bytes` fields, JSON representations are base64 encoded. e.g.:
     * "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is
     * "Zm9vJTI1M0RiYXI=".
     *
     * Generated from protobuf field <code>bytes body = 10;</code>
     * @param string $var
     * @return $this
     */
    public function setBody($var)
    {
        GPBUtil::checkString($var, False);
        $this->body = $var;

        return $this;
    }

}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(HttpCheck::class, \Google\Cloud\Monitoring\V3\UptimeCheckConfig_HttpCheck::class);

