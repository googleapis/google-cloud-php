<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/compute/v1/compute.proto

namespace Google\Cloud\Compute\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * matchRule criteria for request header matches.
 *
 * Generated from protobuf message <code>google.cloud.compute.v1.HttpHeaderMatch</code>
 */
class HttpHeaderMatch extends \Google\Protobuf\Internal\Message
{
    /**
     * The value should exactly match contents of exactMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string exact_match = 457641093;</code>
     */
    private $exact_match = null;
    /**
     * The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method". When the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true, only non-binary user-specified custom metadata and the `content-type` header are supported. The following transport-level headers cannot be used in header matching rules: `:authority`, `:method`, `:path`, `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`, `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
     *
     * Generated from protobuf field <code>optional string header_name = 110223613;</code>
     */
    private $header_name = null;
    /**
     * If set to false, the headerMatch is considered a match if the preceding match criteria are met. If set to true, the headerMatch is considered a match if the preceding match criteria are NOT met. The default setting is false. 
     *
     * Generated from protobuf field <code>optional bool invert_match = 501130268;</code>
     */
    private $invert_match = null;
    /**
     * The value of the header must start with the contents of prefixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string prefix_match = 257898968;</code>
     */
    private $prefix_match = null;
    /**
     * A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional bool present_match = 67435841;</code>
     */
    private $present_match = null;
    /**
     * The header value must be an integer and its value must be in the range specified in rangeMatch. If the header does not contain an integer, number or is empty, the match fails. For example for a range [-5, 0] - -3 will match. - 0 will not match. - 0.25 will not match. - -3someString will not match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. rangeMatch is not supported for load balancers that have loadBalancingScheme set to EXTERNAL.
     *
     * Generated from protobuf field <code>optional .google.cloud.compute.v1.Int64RangeMatch range_match = 97244227;</code>
     */
    private $range_match = null;
    /**
     * The value of the header must match the regular expression specified in regexMatch. For more information about regular expression syntax, see Syntax. For matching against a port specified in the HTTP request, use a headerMatch with headerName set to PORT and a regular expression that satisfies the RFC2616 Host header's port specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. regexMatch only applies to load balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     *
     * Generated from protobuf field <code>optional string regex_match = 107387853;</code>
     */
    private $regex_match = null;
    /**
     * The value of the header must end with the contents of suffixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string suffix_match = 426488663;</code>
     */
    private $suffix_match = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $exact_match
     *           The value should exactly match contents of exactMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *     @type string $header_name
     *           The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method". When the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true, only non-binary user-specified custom metadata and the `content-type` header are supported. The following transport-level headers cannot be used in header matching rules: `:authority`, `:method`, `:path`, `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`, `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
     *     @type bool $invert_match
     *           If set to false, the headerMatch is considered a match if the preceding match criteria are met. If set to true, the headerMatch is considered a match if the preceding match criteria are NOT met. The default setting is false. 
     *     @type string $prefix_match
     *           The value of the header must start with the contents of prefixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *     @type bool $present_match
     *           A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *     @type \Google\Cloud\Compute\V1\Int64RangeMatch $range_match
     *           The header value must be an integer and its value must be in the range specified in rangeMatch. If the header does not contain an integer, number or is empty, the match fails. For example for a range [-5, 0] - -3 will match. - 0 will not match. - 0.25 will not match. - -3someString will not match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. rangeMatch is not supported for load balancers that have loadBalancingScheme set to EXTERNAL.
     *     @type string $regex_match
     *           The value of the header must match the regular expression specified in regexMatch. For more information about regular expression syntax, see Syntax. For matching against a port specified in the HTTP request, use a headerMatch with headerName set to PORT and a regular expression that satisfies the RFC2616 Host header's port specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. regexMatch only applies to load balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     *     @type string $suffix_match
     *           The value of the header must end with the contents of suffixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Google\Cloud\Compute\V1\Compute::initOnce();
        parent::__construct($data);
    }

    /**
     * The value should exactly match contents of exactMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string exact_match = 457641093;</code>
     * @return string
     */
    public function getExactMatch()
    {
        return isset($this->exact_match) ? $this->exact_match : '';
    }

    public function hasExactMatch()
    {
        return isset($this->exact_match);
    }

    public function clearExactMatch()
    {
        unset($this->exact_match);
    }

    /**
     * The value should exactly match contents of exactMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string exact_match = 457641093;</code>
     * @param string $var
     * @return $this
     */
    public function setExactMatch($var)
    {
        GPBUtil::checkString($var, True);
        $this->exact_match = $var;

        return $this;
    }

    /**
     * The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method". When the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true, only non-binary user-specified custom metadata and the `content-type` header are supported. The following transport-level headers cannot be used in header matching rules: `:authority`, `:method`, `:path`, `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`, `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
     *
     * Generated from protobuf field <code>optional string header_name = 110223613;</code>
     * @return string
     */
    public function getHeaderName()
    {
        return isset($this->header_name) ? $this->header_name : '';
    }

    public function hasHeaderName()
    {
        return isset($this->header_name);
    }

    public function clearHeaderName()
    {
        unset($this->header_name);
    }

    /**
     * The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method". When the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true, only non-binary user-specified custom metadata and the `content-type` header are supported. The following transport-level headers cannot be used in header matching rules: `:authority`, `:method`, `:path`, `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`, `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
     *
     * Generated from protobuf field <code>optional string header_name = 110223613;</code>
     * @param string $var
     * @return $this
     */
    public function setHeaderName($var)
    {
        GPBUtil::checkString($var, True);
        $this->header_name = $var;

        return $this;
    }

    /**
     * If set to false, the headerMatch is considered a match if the preceding match criteria are met. If set to true, the headerMatch is considered a match if the preceding match criteria are NOT met. The default setting is false. 
     *
     * Generated from protobuf field <code>optional bool invert_match = 501130268;</code>
     * @return bool
     */
    public function getInvertMatch()
    {
        return isset($this->invert_match) ? $this->invert_match : false;
    }

    public function hasInvertMatch()
    {
        return isset($this->invert_match);
    }

    public function clearInvertMatch()
    {
        unset($this->invert_match);
    }

    /**
     * If set to false, the headerMatch is considered a match if the preceding match criteria are met. If set to true, the headerMatch is considered a match if the preceding match criteria are NOT met. The default setting is false. 
     *
     * Generated from protobuf field <code>optional bool invert_match = 501130268;</code>
     * @param bool $var
     * @return $this
     */
    public function setInvertMatch($var)
    {
        GPBUtil::checkBool($var);
        $this->invert_match = $var;

        return $this;
    }

    /**
     * The value of the header must start with the contents of prefixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string prefix_match = 257898968;</code>
     * @return string
     */
    public function getPrefixMatch()
    {
        return isset($this->prefix_match) ? $this->prefix_match : '';
    }

    public function hasPrefixMatch()
    {
        return isset($this->prefix_match);
    }

    public function clearPrefixMatch()
    {
        unset($this->prefix_match);
    }

    /**
     * The value of the header must start with the contents of prefixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string prefix_match = 257898968;</code>
     * @param string $var
     * @return $this
     */
    public function setPrefixMatch($var)
    {
        GPBUtil::checkString($var, True);
        $this->prefix_match = $var;

        return $this;
    }

    /**
     * A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional bool present_match = 67435841;</code>
     * @return bool
     */
    public function getPresentMatch()
    {
        return isset($this->present_match) ? $this->present_match : false;
    }

    public function hasPresentMatch()
    {
        return isset($this->present_match);
    }

    public function clearPresentMatch()
    {
        unset($this->present_match);
    }

    /**
     * A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional bool present_match = 67435841;</code>
     * @param bool $var
     * @return $this
     */
    public function setPresentMatch($var)
    {
        GPBUtil::checkBool($var);
        $this->present_match = $var;

        return $this;
    }

    /**
     * The header value must be an integer and its value must be in the range specified in rangeMatch. If the header does not contain an integer, number or is empty, the match fails. For example for a range [-5, 0] - -3 will match. - 0 will not match. - 0.25 will not match. - -3someString will not match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. rangeMatch is not supported for load balancers that have loadBalancingScheme set to EXTERNAL.
     *
     * Generated from protobuf field <code>optional .google.cloud.compute.v1.Int64RangeMatch range_match = 97244227;</code>
     * @return \Google\Cloud\Compute\V1\Int64RangeMatch|null
     */
    public function getRangeMatch()
    {
        return $this->range_match;
    }

    public function hasRangeMatch()
    {
        return isset($this->range_match);
    }

    public function clearRangeMatch()
    {
        unset($this->range_match);
    }

    /**
     * The header value must be an integer and its value must be in the range specified in rangeMatch. If the header does not contain an integer, number or is empty, the match fails. For example for a range [-5, 0] - -3 will match. - 0 will not match. - 0.25 will not match. - -3someString will not match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. rangeMatch is not supported for load balancers that have loadBalancingScheme set to EXTERNAL.
     *
     * Generated from protobuf field <code>optional .google.cloud.compute.v1.Int64RangeMatch range_match = 97244227;</code>
     * @param \Google\Cloud\Compute\V1\Int64RangeMatch $var
     * @return $this
     */
    public function setRangeMatch($var)
    {
        GPBUtil::checkMessage($var, \Google\Cloud\Compute\V1\Int64RangeMatch::class);
        $this->range_match = $var;

        return $this;
    }

    /**
     * The value of the header must match the regular expression specified in regexMatch. For more information about regular expression syntax, see Syntax. For matching against a port specified in the HTTP request, use a headerMatch with headerName set to PORT and a regular expression that satisfies the RFC2616 Host header's port specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. regexMatch only applies to load balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     *
     * Generated from protobuf field <code>optional string regex_match = 107387853;</code>
     * @return string
     */
    public function getRegexMatch()
    {
        return isset($this->regex_match) ? $this->regex_match : '';
    }

    public function hasRegexMatch()
    {
        return isset($this->regex_match);
    }

    public function clearRegexMatch()
    {
        unset($this->regex_match);
    }

    /**
     * The value of the header must match the regular expression specified in regexMatch. For more information about regular expression syntax, see Syntax. For matching against a port specified in the HTTP request, use a headerMatch with headerName set to PORT and a regular expression that satisfies the RFC2616 Host header's port specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. regexMatch only applies to load balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     *
     * Generated from protobuf field <code>optional string regex_match = 107387853;</code>
     * @param string $var
     * @return $this
     */
    public function setRegexMatch($var)
    {
        GPBUtil::checkString($var, True);
        $this->regex_match = $var;

        return $this;
    }

    /**
     * The value of the header must end with the contents of suffixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string suffix_match = 426488663;</code>
     * @return string
     */
    public function getSuffixMatch()
    {
        return isset($this->suffix_match) ? $this->suffix_match : '';
    }

    public function hasSuffixMatch()
    {
        return isset($this->suffix_match);
    }

    public function clearSuffixMatch()
    {
        unset($this->suffix_match);
    }

    /**
     * The value of the header must end with the contents of suffixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
     *
     * Generated from protobuf field <code>optional string suffix_match = 426488663;</code>
     * @param string $var
     * @return $this
     */
    public function setSuffixMatch($var)
    {
        GPBUtil::checkString($var, True);
        $this->suffix_match = $var;

        return $this;
    }

}

