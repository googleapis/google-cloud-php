<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/compute/v1/compute.proto

namespace Google\Cloud\Compute\V1\BackendServiceLocalityLoadBalancingPolicyConfigPolicy;

use UnexpectedValueException;

/**
 * The name of a locality load-balancing policy. Valid values include ROUND_ROBIN and, for Java clients, LEAST_REQUEST. For information about these values, see the description of localityLbPolicy. Do not specify the same policy more than once for a backend. If you do, the configuration is rejected.
 *
 * Protobuf type <code>google.cloud.compute.v1.BackendServiceLocalityLoadBalancingPolicyConfigPolicy.Name</code>
 */
class Name
{
    /**
     * A value indicating that the enum field is not set.
     *
     * Generated from protobuf enum <code>UNDEFINED_NAME = 0;</code>
     */
    const UNDEFINED_NAME = 0;
    /**
     * Generated from protobuf enum <code>INVALID_LB_POLICY = 323318707;</code>
     */
    const INVALID_LB_POLICY = 323318707;
    /**
     * An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     *
     * Generated from protobuf enum <code>LEAST_REQUEST = 46604921;</code>
     */
    const LEAST_REQUEST = 46604921;
    /**
     * This algorithm implements consistent hashing to backends. Maglev can be used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     *
     * Generated from protobuf enum <code>MAGLEV = 119180266;</code>
     */
    const MAGLEV = 119180266;
    /**
     * Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     *
     * Generated from protobuf enum <code>ORIGINAL_DESTINATION = 166297216;</code>
     */
    const ORIGINAL_DESTINATION = 166297216;
    /**
     * The load balancer selects a random healthy host.
     *
     * Generated from protobuf enum <code>RANDOM = 262527171;</code>
     */
    const RANDOM = 262527171;
    /**
     * The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     *
     * Generated from protobuf enum <code>RING_HASH = 432795069;</code>
     */
    const RING_HASH = 432795069;
    /**
     * This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     *
     * Generated from protobuf enum <code>ROUND_ROBIN = 153895801;</code>
     */
    const ROUND_ROBIN = 153895801;
    /**
     * Per-instance weighted Load Balancing via health check reported weights. If set, the Backend Service must configure a non legacy HTTP-based Health Check, and health check replies are expected to contain non-standard HTTP response header field X-Load-Balancing-Endpoint-Weight to specify the per-instance weights. If set, Load Balancing is weighted based on the per-instance weights reported in the last processed health check replies, as long as every instance either reported a valid weight or had UNAVAILABLE_WEIGHT. Otherwise, Load Balancing remains equal-weight. This option is only supported in Network Load Balancing.
     *
     * Generated from protobuf enum <code>WEIGHTED_MAGLEV = 254930962;</code>
     */
    const WEIGHTED_MAGLEV = 254930962;

    private static $valueToName = [
        self::UNDEFINED_NAME => 'UNDEFINED_NAME',
        self::INVALID_LB_POLICY => 'INVALID_LB_POLICY',
        self::LEAST_REQUEST => 'LEAST_REQUEST',
        self::MAGLEV => 'MAGLEV',
        self::ORIGINAL_DESTINATION => 'ORIGINAL_DESTINATION',
        self::RANDOM => 'RANDOM',
        self::RING_HASH => 'RING_HASH',
        self::ROUND_ROBIN => 'ROUND_ROBIN',
        self::WEIGHTED_MAGLEV => 'WEIGHTED_MAGLEV',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}


