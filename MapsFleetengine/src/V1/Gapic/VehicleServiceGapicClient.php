<?php
/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * GENERATED CODE WARNING
 * Generated by gapic-generator-php from the file
 * https://github.com/googleapis/googleapis/blob/master/google/maps/fleetengine/v1/vehicle_api.proto
 * Updates to the above are reflected here through a refresh process.
 */

namespace Maps\Fleetengine\V1\Gapic;

use Google\ApiCore\ApiException;
use Google\ApiCore\CredentialsWrapper;
use Google\ApiCore\GapicClientTrait;
use Google\ApiCore\PathTemplate;
use Google\ApiCore\RequestParamsHeaderDescriptor;
use Google\ApiCore\RetrySettings;
use Google\ApiCore\Transport\TransportInterface;
use Google\ApiCore\ValidationException;
use Google\Auth\FetchAuthTokenInterface;
use Google\Geo\Type\Viewport;
use Google\Protobuf\Duration;
use Google\Protobuf\FieldMask;
use Google\Protobuf\Int32Value;
use Google\Protobuf\Timestamp;
use Maps\Fleetengine\V1\CreateVehicleRequest;
use Maps\Fleetengine\V1\GetVehicleRequest;
use Maps\Fleetengine\V1\ListVehiclesRequest;
use Maps\Fleetengine\V1\ListVehiclesResponse;
use Maps\Fleetengine\V1\RequestHeader;
use Maps\Fleetengine\V1\SearchVehiclesRequest;
use Maps\Fleetengine\V1\SearchVehiclesRequest\VehicleMatchOrder;
use Maps\Fleetengine\V1\SearchVehiclesResponse;
use Maps\Fleetengine\V1\TerminalLocation;
use Maps\Fleetengine\V1\TripType;
use Maps\Fleetengine\V1\UpdateVehicleAttributesRequest;
use Maps\Fleetengine\V1\UpdateVehicleAttributesResponse;
use Maps\Fleetengine\V1\UpdateVehicleLocationRequest;
use Maps\Fleetengine\V1\UpdateVehicleRequest;
use Maps\Fleetengine\V1\Vehicle;
use Maps\Fleetengine\V1\VehicleAttribute;
use Maps\Fleetengine\V1\VehicleAttributeList;
use Maps\Fleetengine\V1\VehicleLocation;
use Maps\Fleetengine\V1\VehicleState;
use Maps\Fleetengine\V1\Vehicle\VehicleType;
use Maps\Fleetengine\V1\Vehicle\VehicleType\Category;

/**
 * Service Description: Vehicle management service.
 *
 * This class provides the ability to make remote calls to the backing service through method
 * calls that map to API methods. Sample code to get started:
 *
 * ```
 * $vehicleServiceClient = new VehicleServiceClient();
 * try {
 *     $parent = 'parent';
 *     $vehicleId = 'vehicle_id';
 *     $vehicle = new Vehicle();
 *     $response = $vehicleServiceClient->createVehicle($parent, $vehicleId, $vehicle);
 * } finally {
 *     $vehicleServiceClient->close();
 * }
 * ```
 *
 * Many parameters require resource names to be formatted in a particular way. To
 * assist with these names, this class includes a format method for each type of
 * name, and additionally a parseName method to extract the individual identifiers
 * contained within formatted names that are returned by the API.
 */
class VehicleServiceGapicClient
{
    use GapicClientTrait;

    /** The name of the service. */
    const SERVICE_NAME = 'maps.fleetengine.v1.VehicleService';

    /** The default address of the service. */
    const SERVICE_ADDRESS = 'fleetengine.googleapis.com';

    /** The default port of the service. */
    const DEFAULT_SERVICE_PORT = 443;

    /** The name of the code generator, to be included in the agent header. */
    const CODEGEN_NAME = 'gapic';

    /** The default scopes required by the service. */
    public static $serviceScopes = [
        'https://www.googleapis.com/auth/cloud-platform',
    ];

    private static $vehicleNameTemplate;

    private static $pathTemplateMap;

    private static function getClientDefaults()
    {
        return [
            'serviceName' => self::SERVICE_NAME,
            'apiEndpoint' => self::SERVICE_ADDRESS . ':' . self::DEFAULT_SERVICE_PORT,
            'clientConfig' => __DIR__ . '/../resources/vehicle_service_client_config.json',
            'descriptorsConfigPath' => __DIR__ . '/../resources/vehicle_service_descriptor_config.php',
            'gcpApiConfigPath' => __DIR__ . '/../resources/vehicle_service_grpc_config.json',
            'credentialsConfig' => [
                'defaultScopes' => self::$serviceScopes,
            ],
            'transportConfig' => [
                'rest' => [
                    'restClientConfigPath' => __DIR__ . '/../resources/vehicle_service_rest_client_config.php',
                ],
            ],
        ];
    }

    private static function getVehicleNameTemplate()
    {
        if (self::$vehicleNameTemplate == null) {
            self::$vehicleNameTemplate = new PathTemplate('providers/{provider}/vehicles/{vehicle}');
        }

        return self::$vehicleNameTemplate;
    }

    private static function getPathTemplateMap()
    {
        if (self::$pathTemplateMap == null) {
            self::$pathTemplateMap = [
                'vehicle' => self::getVehicleNameTemplate(),
            ];
        }

        return self::$pathTemplateMap;
    }

    /**
     * Formats a string containing the fully-qualified path to represent a vehicle
     * resource.
     *
     * @param string $provider
     * @param string $vehicle
     *
     * @return string The formatted vehicle resource.
     */
    public static function vehicleName($provider, $vehicle)
    {
        return self::getVehicleNameTemplate()->render([
            'provider' => $provider,
            'vehicle' => $vehicle,
        ]);
    }

    /**
     * Parses a formatted name string and returns an associative array of the components in the name.
     * The following name formats are supported:
     * Template: Pattern
     * - vehicle: providers/{provider}/vehicles/{vehicle}
     *
     * The optional $template argument can be supplied to specify a particular pattern,
     * and must match one of the templates listed above. If no $template argument is
     * provided, or if the $template argument does not match one of the templates
     * listed, then parseName will check each of the supported templates, and return
     * the first match.
     *
     * @param string $formattedName The formatted name string
     * @param string $template      Optional name of template to match
     *
     * @return array An associative array from name component IDs to component values.
     *
     * @throws ValidationException If $formattedName could not be matched.
     */
    public static function parseName($formattedName, $template = null)
    {
        $templateMap = self::getPathTemplateMap();
        if ($template) {
            if (!isset($templateMap[$template])) {
                throw new ValidationException("Template name $template does not exist");
            }

            return $templateMap[$template]->match($formattedName);
        }

        foreach ($templateMap as $templateName => $pathTemplate) {
            try {
                return $pathTemplate->match($formattedName);
            } catch (ValidationException $ex) {
                // Swallow the exception to continue trying other path templates
            }
        }

        throw new ValidationException("Input did not match any known format. Input: $formattedName");
    }

    /**
     * Constructor.
     *
     * @param array $options {
     *     Optional. Options for configuring the service API wrapper.
     *
     *     @type string $apiEndpoint
     *           The address of the API remote host. May optionally include the port, formatted
     *           as "<uri>:<port>". Default 'fleetengine.googleapis.com:443'.
     *     @type string|array|FetchAuthTokenInterface|CredentialsWrapper $credentials
     *           The credentials to be used by the client to authorize API calls. This option
     *           accepts either a path to a credentials file, or a decoded credentials file as a
     *           PHP array.
     *           *Advanced usage*: In addition, this option can also accept a pre-constructed
     *           {@see \Google\Auth\FetchAuthTokenInterface} object or
     *           {@see \Google\ApiCore\CredentialsWrapper} object. Note that when one of these
     *           objects are provided, any settings in $credentialsConfig will be ignored.
     *     @type array $credentialsConfig
     *           Options used to configure credentials, including auth token caching, for the
     *           client. For a full list of supporting configuration options, see
     *           {@see \Google\ApiCore\CredentialsWrapper::build()} .
     *     @type bool $disableRetries
     *           Determines whether or not retries defined by the client configuration should be
     *           disabled. Defaults to `false`.
     *     @type string|array $clientConfig
     *           Client method configuration, including retry settings. This option can be either
     *           a path to a JSON file, or a PHP array containing the decoded JSON data. By
     *           default this settings points to the default client config file, which is
     *           provided in the resources folder.
     *     @type string|TransportInterface $transport
     *           The transport used for executing network requests. May be either the string
     *           `rest` or `grpc`. Defaults to `grpc` if gRPC support is detected on the system.
     *           *Advanced usage*: Additionally, it is possible to pass in an already
     *           instantiated {@see \Google\ApiCore\Transport\TransportInterface} object. Note
     *           that when this object is provided, any settings in $transportConfig, and any
     *           $apiEndpoint setting, will be ignored.
     *     @type array $transportConfig
     *           Configuration options that will be used to construct the transport. Options for
     *           each supported transport type should be passed in a key for that transport. For
     *           example:
     *           $transportConfig = [
     *               'grpc' => [...],
     *               'rest' => [...],
     *           ];
     *           See the {@see \Google\ApiCore\Transport\GrpcTransport::build()} and
     *           {@see \Google\ApiCore\Transport\RestTransport::build()} methods for the
     *           supported options.
     *     @type callable $clientCertSource
     *           A callable which returns the client cert as a string. This can be used to
     *           provide a certificate and private key to the transport layer for mTLS.
     * }
     *
     * @throws ValidationException
     */
    public function __construct(array $options = [])
    {
        $clientOptions = $this->buildClientOptions($options);
        $this->setClientOptions($clientOptions);
    }

    /**
     * Instantiates a new vehicle associated with an on-demand rideshare or
     * deliveries provider. Each `Vehicle` must have a unique vehicle ID.
     *
     * The following `Vehicle` fields are required when creating a `Vehicle`:
     *
     * * `vehicleState`
     * * `supportedTripTypes`
     * * `maximumCapacity`
     * * `vehicleType`
     *
     * The following `Vehicle` fields are ignored when creating a `Vehicle`:
     *
     * * `name`
     * * `currentTrips`
     * * `availableCapacity`
     * * `current_route_segment`
     * * `current_route_segment_end_point`
     * * `current_route_segment_version`
     * * `current_route_segment_traffic`
     * * `route`
     * * `waypoints`
     * * `waypoints_version`
     * * `remaining_distance_meters`
     * * `remaining_time_seconds`
     * * `eta_to_next_waypoint`
     * * `navigation_status`
     *
     * All other fields are optional and used if provided.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $parent = 'parent';
     *     $vehicleId = 'vehicle_id';
     *     $vehicle = new Vehicle();
     *     $response = $vehicleServiceClient->createVehicle($parent, $vehicleId, $vehicle);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string  $parent       Required. Must be in the format `providers/{provider}`.
     *                              The provider must be the Project ID (for example, `sample-cloud-project`)
     *                              of the Google Cloud Project of which the service account making
     *                              this call is a member.
     * @param string  $vehicleId    Required. Unique Vehicle ID.
     *                              Subject to the following restrictions:
     *
     *                              * Must be a valid Unicode string.
     *                              * Limited to a maximum length of 64 characters.
     *                              * Normalized according to [Unicode Normalization Form C]
     *                              (http://www.unicode.org/reports/tr15/).
     *                              * May not contain any of the following ASCII characters: '/', ':', '?',
     *                              ',', or '#'.
     * @param Vehicle $vehicle      Required. The Vehicle entity to create. When creating a Vehicle, the
     *                              following fields are required:
     *
     *                              * `vehicleState`
     *                              * `supportedTripTypes`
     *                              * `maximumCapacity`
     *                              * `vehicleType`
     *
     *                              When creating a Vehicle, the following fields are ignored:
     *
     *                              * `name`
     *                              * `currentTrips`
     *                              * `availableCapacity`
     *                              * `current_route_segment`
     *                              * `current_route_segment_end_point`
     *                              * `current_route_segment_version`
     *                              * `current_route_segment_traffic`
     *                              * `route`
     *                              * `waypoints`
     *                              * `waypoints_version`
     *                              * `remaining_distance_meters`
     *                              * `remaining_time_seconds`
     *                              * `eta_to_next_waypoint`
     *                              * `navigation_status`
     *
     *                              All other fields are optional and used if provided.
     * @param array   $optionalArgs {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\Vehicle
     *
     * @throws ApiException if the remote call fails
     */
    public function createVehicle($parent, $vehicleId, $vehicle, array $optionalArgs = [])
    {
        $request = new CreateVehicleRequest();
        $requestParamHeaders = [];
        $request->setParent($parent);
        $request->setVehicleId($vehicleId);
        $request->setVehicle($vehicle);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $parent, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('CreateVehicle', Vehicle::class, $optionalArgs, $request)->wait();
    }

    /**
     * Returns a vehicle from the Fleet Engine.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $formattedName = $vehicleServiceClient->vehicleName('[PROVIDER]', '[VEHICLE]');
     *     $response = $vehicleServiceClient->getVehicle($formattedName);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string $name         Required. Must be in the format
     *                             `providers/{provider}/vehicles/{vehicle}`.
     *                             The provider must be the Project ID (for example, `sample-cloud-project`)
     *                             of the Google Cloud Project of which the service account making
     *                             this call is a member.
     * @param array  $optionalArgs {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type Timestamp $currentRouteSegmentVersion
     *           Indicates the minimum timestamp (exclusive) for which
     *           `Vehicle.current_route_segment` is retrieved.
     *           If the route is unchanged since this timestamp, the `current_route_segment`
     *           field is not set in the response. If a minimum is unspecified, the
     *           `current_route_segment` is always retrieved.
     *     @type Timestamp $waypointsVersion
     *           Indicates the minimum timestamp (exclusive) for which `Vehicle.waypoints`
     *           data is retrieved. If the waypoints are unchanged since this timestamp, the
     *           `vehicle.waypoints` data is not set in the response. If this field is
     *           unspecified, `vehicle.waypoints` is always retrieved.
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\Vehicle
     *
     * @throws ApiException if the remote call fails
     */
    public function getVehicle($name, array $optionalArgs = [])
    {
        $request = new GetVehicleRequest();
        $requestParamHeaders = [];
        $request->setName($name);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $name, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        if (isset($optionalArgs['currentRouteSegmentVersion'])) {
            $request->setCurrentRouteSegmentVersion($optionalArgs['currentRouteSegmentVersion']);
        }

        if (isset($optionalArgs['waypointsVersion'])) {
            $request->setWaypointsVersion($optionalArgs['waypointsVersion']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('GetVehicle', Vehicle::class, $optionalArgs, $request)->wait();
    }

    /**
     * Returns a paginated list of vehicles associated with
     * a provider that match the request options.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $parent = 'parent';
     *     $vehicleTypeCategories = [];
     *     // Iterate over pages of elements
     *     $pagedResponse = $vehicleServiceClient->listVehicles($parent, $vehicleTypeCategories);
     *     foreach ($pagedResponse->iteratePages() as $page) {
     *         foreach ($page as $element) {
     *             // doSomethingWith($element);
     *         }
     *     }
     *     // Alternatively:
     *     // Iterate through all elements
     *     $pagedResponse = $vehicleServiceClient->listVehicles($parent, $vehicleTypeCategories);
     *     foreach ($pagedResponse->iterateAllElements() as $element) {
     *         // doSomethingWith($element);
     *     }
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string $parent                Required. Must be in the format `providers/{provider}`.
     *                                      The provider must be the Project ID (for example, `sample-cloud-project`)
     *                                      of the Google Cloud Project of which the service account making
     *                                      this call is a member.
     * @param int[]  $vehicleTypeCategories Required. Restricts the response to vehicles with one of the specified type
     *                                      categories. `UNKNOWN` is not allowed.
     *                                      For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\Vehicle\VehicleType\Category}
     * @param array  $optionalArgs          {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type int $pageSize
     *           The maximum number of resources contained in the underlying API
     *           response. The API may return fewer values in a page, even if
     *           there are additional values to be retrieved.
     *     @type string $pageToken
     *           A page token is used to specify a page of values to be returned.
     *           If no page token is specified (the default), the first page
     *           of values will be returned. Any page token used here must have
     *           been generated by a previous call to the API.
     *     @type Int32Value $minimumCapacity
     *           Specifies the required minimum capacity of the vehicle. All vehicles
     *           returned will have a `maximum_capacity` greater than or equal to this
     *           value. If set, must be greater or equal to 0.
     *     @type int[] $tripTypes
     *           Restricts the response to vehicles that support at least one of the
     *           specified trip types.
     *           For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\TripType}
     *     @type Duration $maximumStaleness
     *           Restricts the response to vehicles that have sent location updates to Fleet
     *           Engine within the specified duration. Stationary vehicles still
     *           transmitting their locations are not considered stale. If present, must be
     *           a valid positive duration.
     *     @type string[] $requiredAttributes
     *           Callers can form complex logical operations using any combination of the
     *           `required_attributes`, `required_one_of_attributes`, and
     *           `required_one_of_attribute_sets` fields.
     *
     *           `required_attributes` is a list; `required_one_of_attributes` uses a
     *           message which allows a list of lists. In combination, the two fields allow
     *           the composition of this expression:
     *
     *           ```
     *           (required_attributes[0] AND required_attributes[1] AND ...)
     *           AND
     *           (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     *           ...)
     *           AND
     *           (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     *           ...)
     *           ```
     *
     *           Restricts the response to vehicles with the specified attributes. This
     *           field is a conjunction/AND operation. A max of 50 required_attributes is
     *           allowed. This matches the maximum number of attributes allowed on a
     *           vehicle. Each repeated string should be of the format "key:value".
     *     @type string[] $requiredOneOfAttributes
     *           Restricts the response to vehicles with at least one of the specified
     *           attributes in each `VehicleAttributeList`. Within each list, a vehicle must
     *           match at least one of the attributes. This field is an inclusive
     *           disjunction/OR operation in each `VehicleAttributeList` and a
     *           conjunction/AND operation across the collection of `VehicleAttributeList`.
     *           Each repeated string should be of the format
     *           "key1:value1|key2:value2|key3:value3".
     *     @type string[] $requiredOneOfAttributeSets
     *           `required_one_of_attribute_sets` provides additional functionality.
     *
     *           Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     *           uses a message which allows a list of lists, allowing expressions such as
     *           this one:
     *
     *           ```
     *           (required_attributes[0] AND required_attributes[1] AND ...)
     *           AND
     *           (
     *           (required_one_of_attribute_sets[0][0] AND
     *           required_one_of_attribute_sets[0][1] AND
     *           ...)
     *           OR
     *           (required_one_of_attribute_sets[1][0] AND
     *           required_one_of_attribute_sets[1][1] AND
     *           ...)
     *           )
     *           ```
     *
     *           Restricts the response to vehicles that match all the attributes in a
     *           `VehicleAttributeList`. Within each list, a vehicle must match all of the
     *           attributes. This field is a conjunction/AND operation in each
     *           `VehicleAttributeList` and inclusive disjunction/OR operation across the
     *           collection of `VehicleAttributeList`. Each repeated string should be of the
     *           format "key1:value1|key2:value2|key3:value3".
     *     @type int $vehicleState
     *           Restricts the response to vehicles that have this vehicle state.
     *           For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\VehicleState}
     *     @type bool $onTripOnly
     *           Only return the vehicles with current trip(s).
     *     @type string $filter
     *           Optional. A filter query to apply when listing vehicles. See
     *           http://aip.dev/160 for examples of the filter syntax.
     *
     *           This field is designed to replace the `required_attributes`,
     *           `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     *           If a non-empty value is specified here, the following fields must be empty:
     *           `required_attributes`, `required_one_of_attributes`, and
     *           `required_one_of_attributes_sets`.
     *
     *           This filter functions as an AND clause with other constraints,
     *           such as `vehicle_state` or `on_trip_only`.
     *
     *           Note that the only queries supported are on vehicle attributes (for
     *           example, `attributes.<key> = <value>` or `attributes.<key1> = <value1> AND
     *           attributes.<key2> = <value2>`). The maximum number of restrictions allowed
     *           in a filter query is 50.
     *
     *           Also, all attributes are stored as strings, so the only supported
     *           comparisons against attributes are string comparisons. In order to compare
     *           against number or boolean values, the values must be explicitly quoted to
     *           be treated as strings (for example, `attributes.<key> = "10"` or
     *           `attributes.<key> = "true"`).
     *     @type Viewport $viewport
     *           Optional. A filter that limits the vehicles returned to those whose last
     *           known location was in the rectangular area defined by the viewport.
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Google\ApiCore\PagedListResponse
     *
     * @throws ApiException if the remote call fails
     */
    public function listVehicles($parent, $vehicleTypeCategories, array $optionalArgs = [])
    {
        $request = new ListVehiclesRequest();
        $requestParamHeaders = [];
        $request->setParent($parent);
        $request->setVehicleTypeCategories($vehicleTypeCategories);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $parent, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        if (isset($optionalArgs['pageSize'])) {
            $request->setPageSize($optionalArgs['pageSize']);
        }

        if (isset($optionalArgs['pageToken'])) {
            $request->setPageToken($optionalArgs['pageToken']);
        }

        if (isset($optionalArgs['minimumCapacity'])) {
            $request->setMinimumCapacity($optionalArgs['minimumCapacity']);
        }

        if (isset($optionalArgs['tripTypes'])) {
            $request->setTripTypes($optionalArgs['tripTypes']);
        }

        if (isset($optionalArgs['maximumStaleness'])) {
            $request->setMaximumStaleness($optionalArgs['maximumStaleness']);
        }

        if (isset($optionalArgs['requiredAttributes'])) {
            $request->setRequiredAttributes($optionalArgs['requiredAttributes']);
        }

        if (isset($optionalArgs['requiredOneOfAttributes'])) {
            $request->setRequiredOneOfAttributes($optionalArgs['requiredOneOfAttributes']);
        }

        if (isset($optionalArgs['requiredOneOfAttributeSets'])) {
            $request->setRequiredOneOfAttributeSets($optionalArgs['requiredOneOfAttributeSets']);
        }

        if (isset($optionalArgs['vehicleState'])) {
            $request->setVehicleState($optionalArgs['vehicleState']);
        }

        if (isset($optionalArgs['onTripOnly'])) {
            $request->setOnTripOnly($optionalArgs['onTripOnly']);
        }

        if (isset($optionalArgs['filter'])) {
            $request->setFilter($optionalArgs['filter']);
        }

        if (isset($optionalArgs['viewport'])) {
            $request->setViewport($optionalArgs['viewport']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->getPagedListResponse('ListVehicles', $optionalArgs, ListVehiclesResponse::class, $request);
    }

    /**
     * Deprecated: Use `SearchVehicles` instead.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $parent = 'parent';
     *     $pickupPoint = new TerminalLocation();
     *     $pickupRadiusMeters = 0;
     *     $count = 0;
     *     $minimumCapacity = 0;
     *     $tripTypes = [];
     *     $vehicleTypes = [];
     *     $orderBy = VehicleMatchOrder::UNKNOWN_VEHICLE_MATCH_ORDER;
     *     $response = $vehicleServiceClient->searchFuzzedVehicles($parent, $pickupPoint, $pickupRadiusMeters, $count, $minimumCapacity, $tripTypes, $vehicleTypes, $orderBy);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string           $parent             Required. Must be in the format `providers/{provider}`.
     *                                             The provider must be the Project ID (for example, `sample-cloud-project`)
     *                                             of the Google Cloud Project of which the service account making
     *                                             this call is a member.
     * @param TerminalLocation $pickupPoint        Required. The pickup point to search near.
     * @param int              $pickupRadiusMeters Required. Defines the vehicle search radius around the pickup point. Only
     *                                             vehicles within the search radius will be returned. Value must be between
     *                                             400 and 10000 meters (inclusive).
     * @param int              $count              Required. Specifies the maximum number of vehicles to return. The value
     *                                             must be between 1 and 50 (inclusive).
     * @param int              $minimumCapacity    Required. Specifies the number of passengers being considered for a trip.
     *                                             The value must be greater than or equal to one. The driver is not
     *                                             considered in the capacity value.
     * @param int[]            $tripTypes          Required. Represents the type of proposed trip. Eligible vehicles are those
     *                                             that can support at least one of the specified trip type.
     *
     *                                             `EXCLUSIVE` and `SHARED` may not be included together.
     *                                             `SHARED` is not supported when `current_trips_present` is
     *                                             `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     *                                             For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\TripType}
     * @param VehicleType[]    $vehicleTypes       Required. Restricts the search to vehicles with one of the specified types.
     *                                             At least one vehicle type must be specified. VehicleTypes with a category
     *                                             of `UNKNOWN` are not allowed.
     * @param int              $orderBy            Required. Specifies the desired ordering criterion for results.
     *                                             For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\SearchVehiclesRequest\VehicleMatchOrder}
     * @param array            $optionalArgs       {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type TerminalLocation $dropoffPoint
     *           The customer's intended dropoff location. The field is required if
     *           `trip_types` contains `TripType.SHARED`.
     *     @type Duration $maximumStaleness
     *           Restricts the search to only those vehicles that have sent location updates
     *           to Fleet Engine within the specified duration. Stationary vehicles still
     *           transmitting their locations are not considered stale. If this field is not
     *           set, the server uses five minutes as the default value.
     *     @type VehicleAttribute[] $requiredAttributes
     *           Callers can form complex logical operations using any combination of the
     *           `required_attributes`, `required_one_of_attributes`, and
     *           `required_one_of_attribute_sets` fields.
     *
     *           `required_attributes` is a list; `required_one_of_attributes` uses a
     *           message which allows a list of lists. In combination, the two fields allow
     *           the composition of this expression:
     *
     *           ```
     *           (required_attributes[0] AND required_attributes[1] AND ...)
     *           AND
     *           (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     *           ...)
     *           AND
     *           (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     *           ...)
     *           ```
     *
     *           Restricts the search to only those vehicles with the specified attributes.
     *           This field is a conjunction/AND operation. A max of 50 required_attributes
     *           is allowed. This matches the maximum number of attributes allowed on a
     *           vehicle.
     *     @type VehicleAttributeList[] $requiredOneOfAttributes
     *           Restricts the search to only those vehicles with at least one of
     *           the specified attributes in each `VehicleAttributeList`. Within each
     *           list, a vehicle must match at least one of the attributes. This field is an
     *           inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     *           conjunction/AND operation across the collection of `VehicleAttributeList`.
     *     @type VehicleAttributeList[] $requiredOneOfAttributeSets
     *           `required_one_of_attribute_sets` provides additional functionality.
     *
     *           Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     *           uses a message which allows a list of lists, allowing expressions such as
     *           this one:
     *
     *           ```
     *           (required_attributes[0] AND required_attributes[1] AND ...)
     *           AND
     *           (
     *           (required_one_of_attribute_sets[0][0] AND
     *           required_one_of_attribute_sets[0][1] AND
     *           ...)
     *           OR
     *           (required_one_of_attribute_sets[1][0] AND
     *           required_one_of_attribute_sets[1][1] AND
     *           ...)
     *           )
     *           ```
     *
     *           Restricts the search to only those vehicles with all the attributes in a
     *           `VehicleAttributeList`. Within each list, a
     *           vehicle must match all of the attributes. This field is a conjunction/AND
     *           operation in each `VehicleAttributeList` and inclusive disjunction/OR
     *           operation across the collection of `VehicleAttributeList`.
     *     @type bool $includeBackToBack
     *           Indicates if a vehicle with a single active trip is eligible for another
     *           match. If `false`, vehicles with assigned trips are excluded from the
     *           search results. If `true`, search results include vehicles with
     *           `TripStatus` of `ENROUTE_TO_DROPOFF`.
     *
     *           This field is only considered if a single `trip_type` of `EXCLUSIVE` is
     *           specified.
     *
     *           The default value is `false`.
     *     @type string $tripId
     *           Indicates the trip associated with this `SearchVehicleRequest`.
     *     @type int $currentTripsPresent
     *           Restricts vehicles from appearing in the search results based on
     *           their current trips.
     *
     *           When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     *           `EXCLUSIVE` or `SHARED`, but not both.
     *           For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\SearchVehiclesRequest\CurrentTripsPresent}
     *     @type string $filter
     *           Optional. A filter query to apply when searching vehicles. See
     *           http://aip.dev/160 for examples of the filter syntax.
     *
     *           This field is designed to replace the `required_attributes`,
     *           `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     *           If a non-empty value is specified here, the following fields must be empty:
     *           `required_attributes`, `required_one_of_attributes`, and
     *           `required_one_of_attributes_sets`.
     *
     *           This filter functions as an AND clause with other constraints,
     *           such as `minimum_capacity` or `vehicle_types`.
     *
     *           Note that the only queries supported are on vehicle attributes (for
     *           example, `attributes.<key> = <value>` or `attributes.<key1> = <value1> AND
     *           attributes.<key2> = <value2>`). The maximum number of restrictions allowed
     *           in a filter query is 50.
     *
     *           Also, all attributes are stored as strings, so the only supported
     *           comparisons against attributes are string comparisons. In order to compare
     *           against number or boolean values, the values must be explicitly quoted to
     *           be treated as strings (for example, `attributes.<key> = "10"` or
     *           `attributes.<key> = "true"`).
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\SearchVehiclesResponse
     *
     * @throws ApiException if the remote call fails
     *
     * @deprecated This method will be removed in the next major version update.
     */
    public function searchFuzzedVehicles($parent, $pickupPoint, $pickupRadiusMeters, $count, $minimumCapacity, $tripTypes, $vehicleTypes, $orderBy, array $optionalArgs = [])
    {
        $request = new SearchVehiclesRequest();
        $requestParamHeaders = [];
        $request->setParent($parent);
        $request->setPickupPoint($pickupPoint);
        $request->setPickupRadiusMeters($pickupRadiusMeters);
        $request->setCount($count);
        $request->setMinimumCapacity($minimumCapacity);
        $request->setTripTypes($tripTypes);
        $request->setVehicleTypes($vehicleTypes);
        $request->setOrderBy($orderBy);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $parent, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        if (isset($optionalArgs['dropoffPoint'])) {
            $request->setDropoffPoint($optionalArgs['dropoffPoint']);
        }

        if (isset($optionalArgs['maximumStaleness'])) {
            $request->setMaximumStaleness($optionalArgs['maximumStaleness']);
        }

        if (isset($optionalArgs['requiredAttributes'])) {
            $request->setRequiredAttributes($optionalArgs['requiredAttributes']);
        }

        if (isset($optionalArgs['requiredOneOfAttributes'])) {
            $request->setRequiredOneOfAttributes($optionalArgs['requiredOneOfAttributes']);
        }

        if (isset($optionalArgs['requiredOneOfAttributeSets'])) {
            $request->setRequiredOneOfAttributeSets($optionalArgs['requiredOneOfAttributeSets']);
        }

        if (isset($optionalArgs['includeBackToBack'])) {
            $request->setIncludeBackToBack($optionalArgs['includeBackToBack']);
        }

        if (isset($optionalArgs['tripId'])) {
            $request->setTripId($optionalArgs['tripId']);
        }

        if (isset($optionalArgs['currentTripsPresent'])) {
            $request->setCurrentTripsPresent($optionalArgs['currentTripsPresent']);
        }

        if (isset($optionalArgs['filter'])) {
            $request->setFilter($optionalArgs['filter']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('SearchFuzzedVehicles', SearchVehiclesResponse::class, $optionalArgs, $request)->wait();
    }

    /**
     * Returns a list of vehicles that match the request options.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $parent = 'parent';
     *     $pickupPoint = new TerminalLocation();
     *     $pickupRadiusMeters = 0;
     *     $count = 0;
     *     $minimumCapacity = 0;
     *     $tripTypes = [];
     *     $vehicleTypes = [];
     *     $orderBy = VehicleMatchOrder::UNKNOWN_VEHICLE_MATCH_ORDER;
     *     $response = $vehicleServiceClient->searchVehicles($parent, $pickupPoint, $pickupRadiusMeters, $count, $minimumCapacity, $tripTypes, $vehicleTypes, $orderBy);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string           $parent             Required. Must be in the format `providers/{provider}`.
     *                                             The provider must be the Project ID (for example, `sample-cloud-project`)
     *                                             of the Google Cloud Project of which the service account making
     *                                             this call is a member.
     * @param TerminalLocation $pickupPoint        Required. The pickup point to search near.
     * @param int              $pickupRadiusMeters Required. Defines the vehicle search radius around the pickup point. Only
     *                                             vehicles within the search radius will be returned. Value must be between
     *                                             400 and 10000 meters (inclusive).
     * @param int              $count              Required. Specifies the maximum number of vehicles to return. The value
     *                                             must be between 1 and 50 (inclusive).
     * @param int              $minimumCapacity    Required. Specifies the number of passengers being considered for a trip.
     *                                             The value must be greater than or equal to one. The driver is not
     *                                             considered in the capacity value.
     * @param int[]            $tripTypes          Required. Represents the type of proposed trip. Eligible vehicles are those
     *                                             that can support at least one of the specified trip type.
     *
     *                                             `EXCLUSIVE` and `SHARED` may not be included together.
     *                                             `SHARED` is not supported when `current_trips_present` is
     *                                             `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     *                                             For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\TripType}
     * @param VehicleType[]    $vehicleTypes       Required. Restricts the search to vehicles with one of the specified types.
     *                                             At least one vehicle type must be specified. VehicleTypes with a category
     *                                             of `UNKNOWN` are not allowed.
     * @param int              $orderBy            Required. Specifies the desired ordering criterion for results.
     *                                             For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\SearchVehiclesRequest\VehicleMatchOrder}
     * @param array            $optionalArgs       {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type TerminalLocation $dropoffPoint
     *           The customer's intended dropoff location. The field is required if
     *           `trip_types` contains `TripType.SHARED`.
     *     @type Duration $maximumStaleness
     *           Restricts the search to only those vehicles that have sent location updates
     *           to Fleet Engine within the specified duration. Stationary vehicles still
     *           transmitting their locations are not considered stale. If this field is not
     *           set, the server uses five minutes as the default value.
     *     @type VehicleAttribute[] $requiredAttributes
     *           Callers can form complex logical operations using any combination of the
     *           `required_attributes`, `required_one_of_attributes`, and
     *           `required_one_of_attribute_sets` fields.
     *
     *           `required_attributes` is a list; `required_one_of_attributes` uses a
     *           message which allows a list of lists. In combination, the two fields allow
     *           the composition of this expression:
     *
     *           ```
     *           (required_attributes[0] AND required_attributes[1] AND ...)
     *           AND
     *           (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     *           ...)
     *           AND
     *           (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     *           ...)
     *           ```
     *
     *           Restricts the search to only those vehicles with the specified attributes.
     *           This field is a conjunction/AND operation. A max of 50 required_attributes
     *           is allowed. This matches the maximum number of attributes allowed on a
     *           vehicle.
     *     @type VehicleAttributeList[] $requiredOneOfAttributes
     *           Restricts the search to only those vehicles with at least one of
     *           the specified attributes in each `VehicleAttributeList`. Within each
     *           list, a vehicle must match at least one of the attributes. This field is an
     *           inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     *           conjunction/AND operation across the collection of `VehicleAttributeList`.
     *     @type VehicleAttributeList[] $requiredOneOfAttributeSets
     *           `required_one_of_attribute_sets` provides additional functionality.
     *
     *           Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     *           uses a message which allows a list of lists, allowing expressions such as
     *           this one:
     *
     *           ```
     *           (required_attributes[0] AND required_attributes[1] AND ...)
     *           AND
     *           (
     *           (required_one_of_attribute_sets[0][0] AND
     *           required_one_of_attribute_sets[0][1] AND
     *           ...)
     *           OR
     *           (required_one_of_attribute_sets[1][0] AND
     *           required_one_of_attribute_sets[1][1] AND
     *           ...)
     *           )
     *           ```
     *
     *           Restricts the search to only those vehicles with all the attributes in a
     *           `VehicleAttributeList`. Within each list, a
     *           vehicle must match all of the attributes. This field is a conjunction/AND
     *           operation in each `VehicleAttributeList` and inclusive disjunction/OR
     *           operation across the collection of `VehicleAttributeList`.
     *     @type bool $includeBackToBack
     *           Indicates if a vehicle with a single active trip is eligible for another
     *           match. If `false`, vehicles with assigned trips are excluded from the
     *           search results. If `true`, search results include vehicles with
     *           `TripStatus` of `ENROUTE_TO_DROPOFF`.
     *
     *           This field is only considered if a single `trip_type` of `EXCLUSIVE` is
     *           specified.
     *
     *           The default value is `false`.
     *     @type string $tripId
     *           Indicates the trip associated with this `SearchVehicleRequest`.
     *     @type int $currentTripsPresent
     *           Restricts vehicles from appearing in the search results based on
     *           their current trips.
     *
     *           When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     *           `EXCLUSIVE` or `SHARED`, but not both.
     *           For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\SearchVehiclesRequest\CurrentTripsPresent}
     *     @type string $filter
     *           Optional. A filter query to apply when searching vehicles. See
     *           http://aip.dev/160 for examples of the filter syntax.
     *
     *           This field is designed to replace the `required_attributes`,
     *           `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     *           If a non-empty value is specified here, the following fields must be empty:
     *           `required_attributes`, `required_one_of_attributes`, and
     *           `required_one_of_attributes_sets`.
     *
     *           This filter functions as an AND clause with other constraints,
     *           such as `minimum_capacity` or `vehicle_types`.
     *
     *           Note that the only queries supported are on vehicle attributes (for
     *           example, `attributes.<key> = <value>` or `attributes.<key1> = <value1> AND
     *           attributes.<key2> = <value2>`). The maximum number of restrictions allowed
     *           in a filter query is 50.
     *
     *           Also, all attributes are stored as strings, so the only supported
     *           comparisons against attributes are string comparisons. In order to compare
     *           against number or boolean values, the values must be explicitly quoted to
     *           be treated as strings (for example, `attributes.<key> = "10"` or
     *           `attributes.<key> = "true"`).
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\SearchVehiclesResponse
     *
     * @throws ApiException if the remote call fails
     */
    public function searchVehicles($parent, $pickupPoint, $pickupRadiusMeters, $count, $minimumCapacity, $tripTypes, $vehicleTypes, $orderBy, array $optionalArgs = [])
    {
        $request = new SearchVehiclesRequest();
        $requestParamHeaders = [];
        $request->setParent($parent);
        $request->setPickupPoint($pickupPoint);
        $request->setPickupRadiusMeters($pickupRadiusMeters);
        $request->setCount($count);
        $request->setMinimumCapacity($minimumCapacity);
        $request->setTripTypes($tripTypes);
        $request->setVehicleTypes($vehicleTypes);
        $request->setOrderBy($orderBy);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $parent, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        if (isset($optionalArgs['dropoffPoint'])) {
            $request->setDropoffPoint($optionalArgs['dropoffPoint']);
        }

        if (isset($optionalArgs['maximumStaleness'])) {
            $request->setMaximumStaleness($optionalArgs['maximumStaleness']);
        }

        if (isset($optionalArgs['requiredAttributes'])) {
            $request->setRequiredAttributes($optionalArgs['requiredAttributes']);
        }

        if (isset($optionalArgs['requiredOneOfAttributes'])) {
            $request->setRequiredOneOfAttributes($optionalArgs['requiredOneOfAttributes']);
        }

        if (isset($optionalArgs['requiredOneOfAttributeSets'])) {
            $request->setRequiredOneOfAttributeSets($optionalArgs['requiredOneOfAttributeSets']);
        }

        if (isset($optionalArgs['includeBackToBack'])) {
            $request->setIncludeBackToBack($optionalArgs['includeBackToBack']);
        }

        if (isset($optionalArgs['tripId'])) {
            $request->setTripId($optionalArgs['tripId']);
        }

        if (isset($optionalArgs['currentTripsPresent'])) {
            $request->setCurrentTripsPresent($optionalArgs['currentTripsPresent']);
        }

        if (isset($optionalArgs['filter'])) {
            $request->setFilter($optionalArgs['filter']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('SearchVehicles', SearchVehiclesResponse::class, $optionalArgs, $request)->wait();
    }

    /**
     * Writes updated vehicle data to the Fleet Engine.
     *
     * When updating a `Vehicle`, the following fields cannot be updated since
     * they are managed by the server:
     *
     * * `currentTrips`
     * * `availableCapacity`
     * * `current_route_segment_version`
     * * `waypoints_version`
     *
     * The vehicle `name` also cannot be updated.
     *
     * If the `attributes` field is updated, **all** the vehicle's attributes are
     * replaced with the attributes provided in the request. If you want to update
     * only some attributes, see the `UpdateVehicleAttributes` method. Likewise,
     * the `waypoints` field can be updated, but must contain all the waypoints
     * currently on the vehicle, and no other waypoints.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $name = 'name';
     *     $vehicle = new Vehicle();
     *     $updateMask = new FieldMask();
     *     $response = $vehicleServiceClient->updateVehicle($name, $vehicle, $updateMask);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string    $name         Required. Must be in the format
     *                                `providers/{provider}/vehicles/{vehicle}`.
     *                                The {provider} must be the Project ID (for example, `sample-cloud-project`)
     *                                of the Google Cloud Project of which the service account making
     *                                this call is a member.
     * @param Vehicle   $vehicle      Required. The `Vehicle` entity values to apply.  When updating a `Vehicle`,
     *                                the following fields may not be updated as they are managed by the
     *                                server.
     *
     *                                * `available_capacity`
     *                                * `current_route_segment_version`
     *                                * `current_trips`
     *                                * `name`
     *                                * `waypoints_version`
     *
     *                                If the `attributes` field is updated, **all** the vehicle's attributes are
     *                                replaced with the attributes provided in the request. If you want to update
     *                                only some attributes, see the `UpdateVehicleAttributes` method.
     *
     *                                Likewise, the `waypoints` field can be updated, but must contain all the
     *                                waypoints currently on the vehicle, and no other waypoints.
     * @param FieldMask $updateMask   Required. A field mask indicating which fields of the `Vehicle` to update.
     *                                At least one field name must be provided.
     * @param array     $optionalArgs {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\Vehicle
     *
     * @throws ApiException if the remote call fails
     */
    public function updateVehicle($name, $vehicle, $updateMask, array $optionalArgs = [])
    {
        $request = new UpdateVehicleRequest();
        $requestParamHeaders = [];
        $request->setName($name);
        $request->setVehicle($vehicle);
        $request->setUpdateMask($updateMask);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $name, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('UpdateVehicle', Vehicle::class, $optionalArgs, $request)->wait();
    }

    /**
     * Partially updates a vehicle's attributes.
     * Only the attributes mentioned in the request will be updated, other
     * attributes will NOT be altered. Note: this is different in `UpdateVehicle`,
     * where the whole `attributes` field will be replaced by the one in
     * `UpdateVehicleRequest`, attributes not in the request would be removed.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $name = 'name';
     *     $attributes = [];
     *     $response = $vehicleServiceClient->updateVehicleAttributes($name, $attributes);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string             $name         Required. Must be in the format `providers/{provider}/vehicles/{vehicle}`.
     *                                         The provider must be the Project ID (for example, `sample-cloud-project`)
     *                                         of the Google Cloud Project of which the service account making
     *                                         this call is a member.
     * @param VehicleAttribute[] $attributes   Required. The vehicle attributes to update. Unmentioned attributes are not
     *                                         altered or removed.
     * @param array              $optionalArgs {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\UpdateVehicleAttributesResponse
     *
     * @throws ApiException if the remote call fails
     */
    public function updateVehicleAttributes($name, $attributes, array $optionalArgs = [])
    {
        $request = new UpdateVehicleAttributesRequest();
        $requestParamHeaders = [];
        $request->setName($name);
        $request->setAttributes($attributes);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $name, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('UpdateVehicleAttributes', UpdateVehicleAttributesResponse::class, $optionalArgs, $request)->wait();
    }

    /**
     * Deprecated: Use the `UpdateVehicle` method instead.
     * UpdateVehicleLocation updates the location of the vehicle.
     *
     * Sample code:
     * ```
     * $vehicleServiceClient = new VehicleServiceClient();
     * try {
     *     $name = 'name';
     *     $currentLocation = new VehicleLocation();
     *     $response = $vehicleServiceClient->updateVehicleLocation($name, $currentLocation);
     * } finally {
     *     $vehicleServiceClient->close();
     * }
     * ```
     *
     * @param string          $name            Required. Must be in the format
     *                                         `providers/{provider}/vehicles/{vehicle}`.
     *                                         The {provider} must be the Project ID (for example, `sample-cloud-project`)
     *                                         of the Google Cloud Project of which the service account making
     *                                         this call is a member.
     * @param VehicleLocation $currentLocation Required. The vehicle's most recent location.  The `location` and
     *                                         `update_time` subfields are required.
     * @param array           $optionalArgs    {
     *     Optional.
     *
     *     @type RequestHeader $header
     *           The standard Fleet Engine request header.
     *     @type int $currentState
     *           Set the vehicle's state to either `ONLINE` or `OFFLINE`.
     *           If set to `UNKNOWN_VEHICLE_STATE`, the vehicle's state will not be altered.
     *           For allowed values, use constants defined on {@see \Maps\Fleetengine\V1\VehicleState}
     *     @type RetrySettings|array $retrySettings
     *           Retry settings to use for this call. Can be a {@see RetrySettings} object, or an
     *           associative array of retry settings parameters. See the documentation on
     *           {@see RetrySettings} for example usage.
     * }
     *
     * @return \Maps\Fleetengine\V1\VehicleLocation
     *
     * @throws ApiException if the remote call fails
     *
     * @deprecated This method will be removed in the next major version update.
     */
    public function updateVehicleLocation($name, $currentLocation, array $optionalArgs = [])
    {
        $request = new UpdateVehicleLocationRequest();
        $requestParamHeaders = [];
        $request->setName($name);
        $request->setCurrentLocation($currentLocation);
        $providerIdMatches = [];
        if (preg_match('/^(?<provider_id>providers\/[^\/]+)$/', $name, $providerIdMatches)) {
            $requestParamHeaders['provider_id'] = $providerIdMatches['provider_id'];
        }

        if (isset($optionalArgs['header'])) {
            $request->setHeader($optionalArgs['header']);
        }

        if (isset($optionalArgs['currentState'])) {
            $request->setCurrentState($optionalArgs['currentState']);
        }

        $requestParams = new RequestParamsHeaderDescriptor($requestParamHeaders);
        $optionalArgs['headers'] = isset($optionalArgs['headers']) ? array_merge($requestParams->getHeader(), $optionalArgs['headers']) : $requestParams->getHeader();
        return $this->startCall('UpdateVehicleLocation', VehicleLocation::class, $optionalArgs, $request)->wait();
    }
}
