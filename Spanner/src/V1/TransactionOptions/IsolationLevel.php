<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/spanner/v1/transaction.proto

namespace Google\Cloud\Spanner\V1\TransactionOptions;

use UnexpectedValueException;

/**
 * `IsolationLevel` is used when setting `isolation_level` for a transaction.
 *
 * Protobuf type <code>google.spanner.v1.TransactionOptions.IsolationLevel</code>
 */
class IsolationLevel
{
    /**
     * Default value.
     * If the value is not specified, the `SERIALIZABLE` isolation level is
     * used.
     *
     * Generated from protobuf enum <code>ISOLATION_LEVEL_UNSPECIFIED = 0;</code>
     */
    const ISOLATION_LEVEL_UNSPECIFIED = 0;
    /**
     * All transactions appear as if they executed in a serial order, even if
     * some of the reads, writes, and other operations of distinct transactions
     * actually occurred in parallel. Spanner assigns commit timestamps that
     * reflect the order of committed transactions to implement this property.
     * Spanner offers a stronger guarantee than serializability called external
     * consistency. For further details, please refer to
     * https://cloud.google.com/spanner/docs/true-time-external-consistency#serializability.
     *
     * Generated from protobuf enum <code>SERIALIZABLE = 1;</code>
     */
    const SERIALIZABLE = 1;
    /**
     * All reads performed during the transaction observe a consistent snapshot
     * of the database, and the transaction will only successfully commit in the
     * absence of conflicts between its updates and any concurrent updates that
     * have occurred since that snapshot. Consequently, in contrast to
     * `SERIALIZABLE` transactions, only write-write conflicts are detected in
     * snapshot transactions.
     * This isolation level does not support Read-only and Partitioned DML
     * transactions.
     * When `REPEATABLE_READ` is specified on a read-write transaction, the
     * locking semantics default to `OPTIMISTIC`.
     *
     * Generated from protobuf enum <code>REPEATABLE_READ = 2;</code>
     */
    const REPEATABLE_READ = 2;

    private static $valueToName = [
        self::ISOLATION_LEVEL_UNSPECIFIED => 'ISOLATION_LEVEL_UNSPECIFIED',
        self::SERIALIZABLE => 'SERIALIZABLE',
        self::REPEATABLE_READ => 'REPEATABLE_READ',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(IsolationLevel::class, \Google\Cloud\Spanner\V1\TransactionOptions_IsolationLevel::class);

