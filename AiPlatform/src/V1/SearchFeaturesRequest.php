<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/aiplatform/v1/featurestore_service.proto

namespace Google\Cloud\AIPlatform\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Request message for
 * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
 *
 * Generated from protobuf message <code>google.cloud.aiplatform.v1.SearchFeaturesRequest</code>
 */
class SearchFeaturesRequest extends \Google\Protobuf\Internal\Message
{
    /**
     * Required. The resource name of the Location to search Features.
     * Format:
     * `projects/{project}/locations/{location}`
     *
     * Generated from protobuf field <code>string location = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {</code>
     */
    private $location = '';
    /**
     * Query string that is a conjunction of field-restricted queries and/or
     * field-restricted filters.  Field-restricted queries and filters can be
     * combined using `AND` to form a conjunction.
     * A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
     * exists as a substring within Feature's FIELD. The QUERY
     * and the FIELD are converted to a sequence of words (i.e. tokens) for
     * comparison. This is done by:
     *   * Removing leading/trailing whitespace and tokenizing the search value.
     *   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
     *   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
     *   as a wildcard that matches characters within a token.
     *   * Ignoring case.
     *   * Prepending an asterisk to the first and appending an asterisk to the
     *   last token in QUERY.
     * A QUERY must be either a singular token or a phrase. A phrase is one or
     * multiple words enclosed in double quotation marks ("). With phrases, the
     * order of the words is important. Words in the phrase must be matching in
     * order and consecutively.
     * Supported FIELDs for field-restricted queries:
     * * `feature_id`
     * * `description`
     * * `entity_type_id`
     * Examples:
     * * `feature_id: foo` --> Matches a Feature with ID containing the substring
     * `foo` (eg. `foo`, `foofeature`, `barfoo`).
     * * `feature_id: foo*feature` --> Matches a Feature with ID containing the
     * substring `foo*feature` (eg. `foobarfeature`).
     * * `feature_id: foo AND description: bar` --> Matches a Feature with ID
     * containing the substring `foo` and description containing the substring
     * `bar`.
     * Besides field queries, the following exact-match filters are
     * supported. The exact-match filters do not support wildcards. Unlike
     * field-restricted queries, exact-match filters are case-sensitive.
     * * `feature_id`: Supports = comparisons.
     * * `description`: Supports = comparisons. Multi-token filters should be
     * enclosed in quotes.
     * * `entity_type_id`: Supports = comparisons.
     * * `value_type`: Supports = and != comparisons.
     * * `labels`: Supports key-value equality as well as key presence.
     * * `featurestore_id`: Supports = comparisons.
     * Examples:
     * * `description = "foo bar"` --> Any Feature with description exactly equal
     * to `foo bar`
     * * `value_type = DOUBLE` --> Features whose type is DOUBLE.
     * * `labels.active = yes AND labels.env = prod` --> Features having both
     *     (active: yes) and (env: prod) labels.
     * * `labels.env: *` --> Any Feature which has a label with `env` as the
     *   key.
     *
     * Generated from protobuf field <code>string query = 3;</code>
     */
    private $query = '';
    /**
     * The maximum number of Features to return. The service may return fewer
     * than this value. If unspecified, at most 100 Features will be returned.
     * The maximum value is 100; any value greater than 100 will be coerced to
     * 100.
     *
     * Generated from protobuf field <code>int32 page_size = 4;</code>
     */
    private $page_size = 0;
    /**
     * A page token, received from a previous
     * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
     * call. Provide this to retrieve the subsequent page.
     * When paginating, all other parameters provided to
     * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
     * except `page_size`, must match the call that provided the page token.
     *
     * Generated from protobuf field <code>string page_token = 5;</code>
     */
    private $page_token = '';

    /**
     * @param string $location Required. The resource name of the Location to search Features.
     *                         Format:
     *                         `projects/{project}/locations/{location}`
     *                         Please see {@see FeaturestoreServiceClient::locationName()} for help formatting this field.
     *
     * @return \Google\Cloud\AIPlatform\V1\SearchFeaturesRequest
     *
     * @experimental
     */
    public static function build(string $location): self
    {
        return (new self())
            ->setLocation($location);
    }

    /**
     * @param string $location Required. The resource name of the Location to search Features.
     *                         Format:
     *                         `projects/{project}/locations/{location}`
     *                         Please see {@see FeaturestoreServiceClient::locationName()} for help formatting this field.
     * @param string $query    Query string that is a conjunction of field-restricted queries and/or
     *                         field-restricted filters.  Field-restricted queries and filters can be
     *                         combined using `AND` to form a conjunction.
     *
     *                         A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
     *                         exists as a substring within Feature's FIELD. The QUERY
     *                         and the FIELD are converted to a sequence of words (i.e. tokens) for
     *                         comparison. This is done by:
     *
     *                         * Removing leading/trailing whitespace and tokenizing the search value.
     *                         Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
     *                         `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
     *                         as a wildcard that matches characters within a token.
     *                         * Ignoring case.
     *                         * Prepending an asterisk to the first and appending an asterisk to the
     *                         last token in QUERY.
     *
     *                         A QUERY must be either a singular token or a phrase. A phrase is one or
     *                         multiple words enclosed in double quotation marks ("). With phrases, the
     *                         order of the words is important. Words in the phrase must be matching in
     *                         order and consecutively.
     *
     *                         Supported FIELDs for field-restricted queries:
     *
     *                         * `feature_id`
     *                         * `description`
     *                         * `entity_type_id`
     *
     *                         Examples:
     *
     *                         * `feature_id: foo` --> Matches a Feature with ID containing the substring
     *                         `foo` (eg. `foo`, `foofeature`, `barfoo`).
     *                         * `feature_id: foo*feature` --> Matches a Feature with ID containing the
     *                         substring `foo*feature` (eg. `foobarfeature`).
     *                         * `feature_id: foo AND description: bar` --> Matches a Feature with ID
     *                         containing the substring `foo` and description containing the substring
     *                         `bar`.
     *
     *
     *                         Besides field queries, the following exact-match filters are
     *                         supported. The exact-match filters do not support wildcards. Unlike
     *                         field-restricted queries, exact-match filters are case-sensitive.
     *
     *                         * `feature_id`: Supports = comparisons.
     *                         * `description`: Supports = comparisons. Multi-token filters should be
     *                         enclosed in quotes.
     *                         * `entity_type_id`: Supports = comparisons.
     *                         * `value_type`: Supports = and != comparisons.
     *                         * `labels`: Supports key-value equality as well as key presence.
     *                         * `featurestore_id`: Supports = comparisons.
     *
     *                         Examples:
     *
     *                         * `description = "foo bar"` --> Any Feature with description exactly equal
     *                         to `foo bar`
     *                         * `value_type = DOUBLE` --> Features whose type is DOUBLE.
     *                         * `labels.active = yes AND labels.env = prod` --> Features having both
     *                         (active: yes) and (env: prod) labels.
     *                         * `labels.env: *` --> Any Feature which has a label with `env` as the
     *                         key.
     *
     * @return \Google\Cloud\AIPlatform\V1\SearchFeaturesRequest
     *
     * @experimental
     */
    public static function buildFromLocationQuery(string $location, string $query): self
    {
        return (new self())
            ->setLocation($location)
            ->setQuery($query);
    }

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $location
     *           Required. The resource name of the Location to search Features.
     *           Format:
     *           `projects/{project}/locations/{location}`
     *     @type string $query
     *           Query string that is a conjunction of field-restricted queries and/or
     *           field-restricted filters.  Field-restricted queries and filters can be
     *           combined using `AND` to form a conjunction.
     *           A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
     *           exists as a substring within Feature's FIELD. The QUERY
     *           and the FIELD are converted to a sequence of words (i.e. tokens) for
     *           comparison. This is done by:
     *             * Removing leading/trailing whitespace and tokenizing the search value.
     *             Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
     *             `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
     *             as a wildcard that matches characters within a token.
     *             * Ignoring case.
     *             * Prepending an asterisk to the first and appending an asterisk to the
     *             last token in QUERY.
     *           A QUERY must be either a singular token or a phrase. A phrase is one or
     *           multiple words enclosed in double quotation marks ("). With phrases, the
     *           order of the words is important. Words in the phrase must be matching in
     *           order and consecutively.
     *           Supported FIELDs for field-restricted queries:
     *           * `feature_id`
     *           * `description`
     *           * `entity_type_id`
     *           Examples:
     *           * `feature_id: foo` --> Matches a Feature with ID containing the substring
     *           `foo` (eg. `foo`, `foofeature`, `barfoo`).
     *           * `feature_id: foo*feature` --> Matches a Feature with ID containing the
     *           substring `foo*feature` (eg. `foobarfeature`).
     *           * `feature_id: foo AND description: bar` --> Matches a Feature with ID
     *           containing the substring `foo` and description containing the substring
     *           `bar`.
     *           Besides field queries, the following exact-match filters are
     *           supported. The exact-match filters do not support wildcards. Unlike
     *           field-restricted queries, exact-match filters are case-sensitive.
     *           * `feature_id`: Supports = comparisons.
     *           * `description`: Supports = comparisons. Multi-token filters should be
     *           enclosed in quotes.
     *           * `entity_type_id`: Supports = comparisons.
     *           * `value_type`: Supports = and != comparisons.
     *           * `labels`: Supports key-value equality as well as key presence.
     *           * `featurestore_id`: Supports = comparisons.
     *           Examples:
     *           * `description = "foo bar"` --> Any Feature with description exactly equal
     *           to `foo bar`
     *           * `value_type = DOUBLE` --> Features whose type is DOUBLE.
     *           * `labels.active = yes AND labels.env = prod` --> Features having both
     *               (active: yes) and (env: prod) labels.
     *           * `labels.env: *` --> Any Feature which has a label with `env` as the
     *             key.
     *     @type int $page_size
     *           The maximum number of Features to return. The service may return fewer
     *           than this value. If unspecified, at most 100 Features will be returned.
     *           The maximum value is 100; any value greater than 100 will be coerced to
     *           100.
     *     @type string $page_token
     *           A page token, received from a previous
     *           [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
     *           call. Provide this to retrieve the subsequent page.
     *           When paginating, all other parameters provided to
     *           [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
     *           except `page_size`, must match the call that provided the page token.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Google\Cloud\Aiplatform\V1\FeaturestoreService::initOnce();
        parent::__construct($data);
    }

    /**
     * Required. The resource name of the Location to search Features.
     * Format:
     * `projects/{project}/locations/{location}`
     *
     * Generated from protobuf field <code>string location = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {</code>
     * @return string
     */
    public function getLocation()
    {
        return $this->location;
    }

    /**
     * Required. The resource name of the Location to search Features.
     * Format:
     * `projects/{project}/locations/{location}`
     *
     * Generated from protobuf field <code>string location = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {</code>
     * @param string $var
     * @return $this
     */
    public function setLocation($var)
    {
        GPBUtil::checkString($var, True);
        $this->location = $var;

        return $this;
    }

    /**
     * Query string that is a conjunction of field-restricted queries and/or
     * field-restricted filters.  Field-restricted queries and filters can be
     * combined using `AND` to form a conjunction.
     * A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
     * exists as a substring within Feature's FIELD. The QUERY
     * and the FIELD are converted to a sequence of words (i.e. tokens) for
     * comparison. This is done by:
     *   * Removing leading/trailing whitespace and tokenizing the search value.
     *   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
     *   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
     *   as a wildcard that matches characters within a token.
     *   * Ignoring case.
     *   * Prepending an asterisk to the first and appending an asterisk to the
     *   last token in QUERY.
     * A QUERY must be either a singular token or a phrase. A phrase is one or
     * multiple words enclosed in double quotation marks ("). With phrases, the
     * order of the words is important. Words in the phrase must be matching in
     * order and consecutively.
     * Supported FIELDs for field-restricted queries:
     * * `feature_id`
     * * `description`
     * * `entity_type_id`
     * Examples:
     * * `feature_id: foo` --> Matches a Feature with ID containing the substring
     * `foo` (eg. `foo`, `foofeature`, `barfoo`).
     * * `feature_id: foo*feature` --> Matches a Feature with ID containing the
     * substring `foo*feature` (eg. `foobarfeature`).
     * * `feature_id: foo AND description: bar` --> Matches a Feature with ID
     * containing the substring `foo` and description containing the substring
     * `bar`.
     * Besides field queries, the following exact-match filters are
     * supported. The exact-match filters do not support wildcards. Unlike
     * field-restricted queries, exact-match filters are case-sensitive.
     * * `feature_id`: Supports = comparisons.
     * * `description`: Supports = comparisons. Multi-token filters should be
     * enclosed in quotes.
     * * `entity_type_id`: Supports = comparisons.
     * * `value_type`: Supports = and != comparisons.
     * * `labels`: Supports key-value equality as well as key presence.
     * * `featurestore_id`: Supports = comparisons.
     * Examples:
     * * `description = "foo bar"` --> Any Feature with description exactly equal
     * to `foo bar`
     * * `value_type = DOUBLE` --> Features whose type is DOUBLE.
     * * `labels.active = yes AND labels.env = prod` --> Features having both
     *     (active: yes) and (env: prod) labels.
     * * `labels.env: *` --> Any Feature which has a label with `env` as the
     *   key.
     *
     * Generated from protobuf field <code>string query = 3;</code>
     * @return string
     */
    public function getQuery()
    {
        return $this->query;
    }

    /**
     * Query string that is a conjunction of field-restricted queries and/or
     * field-restricted filters.  Field-restricted queries and filters can be
     * combined using `AND` to form a conjunction.
     * A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
     * exists as a substring within Feature's FIELD. The QUERY
     * and the FIELD are converted to a sequence of words (i.e. tokens) for
     * comparison. This is done by:
     *   * Removing leading/trailing whitespace and tokenizing the search value.
     *   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
     *   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
     *   as a wildcard that matches characters within a token.
     *   * Ignoring case.
     *   * Prepending an asterisk to the first and appending an asterisk to the
     *   last token in QUERY.
     * A QUERY must be either a singular token or a phrase. A phrase is one or
     * multiple words enclosed in double quotation marks ("). With phrases, the
     * order of the words is important. Words in the phrase must be matching in
     * order and consecutively.
     * Supported FIELDs for field-restricted queries:
     * * `feature_id`
     * * `description`
     * * `entity_type_id`
     * Examples:
     * * `feature_id: foo` --> Matches a Feature with ID containing the substring
     * `foo` (eg. `foo`, `foofeature`, `barfoo`).
     * * `feature_id: foo*feature` --> Matches a Feature with ID containing the
     * substring `foo*feature` (eg. `foobarfeature`).
     * * `feature_id: foo AND description: bar` --> Matches a Feature with ID
     * containing the substring `foo` and description containing the substring
     * `bar`.
     * Besides field queries, the following exact-match filters are
     * supported. The exact-match filters do not support wildcards. Unlike
     * field-restricted queries, exact-match filters are case-sensitive.
     * * `feature_id`: Supports = comparisons.
     * * `description`: Supports = comparisons. Multi-token filters should be
     * enclosed in quotes.
     * * `entity_type_id`: Supports = comparisons.
     * * `value_type`: Supports = and != comparisons.
     * * `labels`: Supports key-value equality as well as key presence.
     * * `featurestore_id`: Supports = comparisons.
     * Examples:
     * * `description = "foo bar"` --> Any Feature with description exactly equal
     * to `foo bar`
     * * `value_type = DOUBLE` --> Features whose type is DOUBLE.
     * * `labels.active = yes AND labels.env = prod` --> Features having both
     *     (active: yes) and (env: prod) labels.
     * * `labels.env: *` --> Any Feature which has a label with `env` as the
     *   key.
     *
     * Generated from protobuf field <code>string query = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setQuery($var)
    {
        GPBUtil::checkString($var, True);
        $this->query = $var;

        return $this;
    }

    /**
     * The maximum number of Features to return. The service may return fewer
     * than this value. If unspecified, at most 100 Features will be returned.
     * The maximum value is 100; any value greater than 100 will be coerced to
     * 100.
     *
     * Generated from protobuf field <code>int32 page_size = 4;</code>
     * @return int
     */
    public function getPageSize()
    {
        return $this->page_size;
    }

    /**
     * The maximum number of Features to return. The service may return fewer
     * than this value. If unspecified, at most 100 Features will be returned.
     * The maximum value is 100; any value greater than 100 will be coerced to
     * 100.
     *
     * Generated from protobuf field <code>int32 page_size = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setPageSize($var)
    {
        GPBUtil::checkInt32($var);
        $this->page_size = $var;

        return $this;
    }

    /**
     * A page token, received from a previous
     * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
     * call. Provide this to retrieve the subsequent page.
     * When paginating, all other parameters provided to
     * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
     * except `page_size`, must match the call that provided the page token.
     *
     * Generated from protobuf field <code>string page_token = 5;</code>
     * @return string
     */
    public function getPageToken()
    {
        return $this->page_token;
    }

    /**
     * A page token, received from a previous
     * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
     * call. Provide this to retrieve the subsequent page.
     * When paginating, all other parameters provided to
     * [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
     * except `page_size`, must match the call that provided the page token.
     *
     * Generated from protobuf field <code>string page_token = 5;</code>
     * @param string $var
     * @return $this
     */
    public function setPageToken($var)
    {
        GPBUtil::checkString($var, True);
        $this->page_token = $var;

        return $this;
    }

}

