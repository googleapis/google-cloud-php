<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/aiplatform/v1/study.proto

namespace Google\Cloud\AIPlatform\V1\StudySpec;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * The configuration (stopping conditions) for automated stopping of a Study.
 * Conditions include trial budgets, time budgets, and convergence detection.
 *
 * Generated from protobuf message <code>google.cloud.aiplatform.v1.StudySpec.StudyStoppingConfig</code>
 */
class StudyStoppingConfig extends \Google\Protobuf\Internal\Message
{
    /**
     * If true, a Study enters STOPPING_ASAP whenever it would normally enters
     * STOPPING state.
     * The bottom line is: set to true if you want to interrupt on-going
     * evaluations of Trials as soon as the study stopping condition is met.
     * (Please see Study.State documentation for the source of truth).
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue should_stop_asap = 1;</code>
     */
    protected $should_stop_asap = null;
    /**
     * Each "stopping rule" in this proto specifies an "if" condition. Before
     * Vizier would generate a new suggestion, it first checks each specified
     * stopping rule, from top to bottom in this list.
     * Note that the first few rules (e.g. minimum_runtime_constraint,
     * min_num_trials) will prevent other stopping rules from being evaluated
     * until they are met. For example, setting `min_num_trials=5` and
     * `always_stop_after= 1 hour` means that the Study will ONLY stop after it
     * has 5 COMPLETED trials, even if more than an hour has passed since its
     * creation. It follows the first applicable rule (whose "if" condition is
     * satisfied) to make a stopping decision. If none of the specified rules
     * are applicable, then Vizier decides that the study should not stop.
     * If Vizier decides that the study should stop, the study enters
     * STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
     * IMPORTANT: The automatic study state transition happens precisely as
     * described above; that is, deleting trials or updating StudyConfig NEVER
     * automatically moves the study state back to ACTIVE. If you want to
     * _resume_ a Study that was stopped, 1) change the stopping conditions if
     * necessary, 2) activate the study, and then 3) ask for suggestions.
     * If the specified time or duration has not passed, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.cloud.aiplatform.v1.StudyTimeConstraint minimum_runtime_constraint = 2;</code>
     */
    protected $minimum_runtime_constraint = null;
    /**
     * If the specified time or duration has passed, stop the study.
     *
     * Generated from protobuf field <code>.google.cloud.aiplatform.v1.StudyTimeConstraint maximum_runtime_constraint = 3;</code>
     */
    protected $maximum_runtime_constraint = null;
    /**
     * If there are fewer than this many COMPLETED trials, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value min_num_trials = 4;</code>
     */
    protected $min_num_trials = null;
    /**
     * If there are more than this many trials, stop the study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials = 5;</code>
     */
    protected $max_num_trials = null;
    /**
     * If the objective value has not improved for this many consecutive
     * trials, stop the study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials_no_progress = 6;</code>
     */
    protected $max_num_trials_no_progress = null;
    /**
     * If the objective value has not improved for this much time, stop the
     * study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration max_duration_no_progress = 7;</code>
     */
    protected $max_duration_no_progress = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Google\Protobuf\BoolValue $should_stop_asap
     *           If true, a Study enters STOPPING_ASAP whenever it would normally enters
     *           STOPPING state.
     *           The bottom line is: set to true if you want to interrupt on-going
     *           evaluations of Trials as soon as the study stopping condition is met.
     *           (Please see Study.State documentation for the source of truth).
     *     @type \Google\Cloud\AIPlatform\V1\StudyTimeConstraint $minimum_runtime_constraint
     *           Each "stopping rule" in this proto specifies an "if" condition. Before
     *           Vizier would generate a new suggestion, it first checks each specified
     *           stopping rule, from top to bottom in this list.
     *           Note that the first few rules (e.g. minimum_runtime_constraint,
     *           min_num_trials) will prevent other stopping rules from being evaluated
     *           until they are met. For example, setting `min_num_trials=5` and
     *           `always_stop_after= 1 hour` means that the Study will ONLY stop after it
     *           has 5 COMPLETED trials, even if more than an hour has passed since its
     *           creation. It follows the first applicable rule (whose "if" condition is
     *           satisfied) to make a stopping decision. If none of the specified rules
     *           are applicable, then Vizier decides that the study should not stop.
     *           If Vizier decides that the study should stop, the study enters
     *           STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
     *           IMPORTANT: The automatic study state transition happens precisely as
     *           described above; that is, deleting trials or updating StudyConfig NEVER
     *           automatically moves the study state back to ACTIVE. If you want to
     *           _resume_ a Study that was stopped, 1) change the stopping conditions if
     *           necessary, 2) activate the study, and then 3) ask for suggestions.
     *           If the specified time or duration has not passed, do not stop the
     *           study.
     *     @type \Google\Cloud\AIPlatform\V1\StudyTimeConstraint $maximum_runtime_constraint
     *           If the specified time or duration has passed, stop the study.
     *     @type \Google\Protobuf\Int32Value $min_num_trials
     *           If there are fewer than this many COMPLETED trials, do not stop the
     *           study.
     *     @type \Google\Protobuf\Int32Value $max_num_trials
     *           If there are more than this many trials, stop the study.
     *     @type \Google\Protobuf\Int32Value $max_num_trials_no_progress
     *           If the objective value has not improved for this many consecutive
     *           trials, stop the study.
     *           WARNING: Effective only for single-objective studies.
     *     @type \Google\Protobuf\Duration $max_duration_no_progress
     *           If the objective value has not improved for this much time, stop the
     *           study.
     *           WARNING: Effective only for single-objective studies.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Google\Cloud\Aiplatform\V1\Study::initOnce();
        parent::__construct($data);
    }

    /**
     * If true, a Study enters STOPPING_ASAP whenever it would normally enters
     * STOPPING state.
     * The bottom line is: set to true if you want to interrupt on-going
     * evaluations of Trials as soon as the study stopping condition is met.
     * (Please see Study.State documentation for the source of truth).
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue should_stop_asap = 1;</code>
     * @return \Google\Protobuf\BoolValue|null
     */
    public function getShouldStopAsap()
    {
        return $this->should_stop_asap;
    }

    public function hasShouldStopAsap()
    {
        return isset($this->should_stop_asap);
    }

    public function clearShouldStopAsap()
    {
        unset($this->should_stop_asap);
    }

    /**
     * Returns the unboxed value from <code>getShouldStopAsap()</code>

     * If true, a Study enters STOPPING_ASAP whenever it would normally enters
     * STOPPING state.
     * The bottom line is: set to true if you want to interrupt on-going
     * evaluations of Trials as soon as the study stopping condition is met.
     * (Please see Study.State documentation for the source of truth).
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue should_stop_asap = 1;</code>
     * @return bool|null
     */
    public function getShouldStopAsapUnwrapped()
    {
        return $this->readWrapperValue("should_stop_asap");
    }

    /**
     * If true, a Study enters STOPPING_ASAP whenever it would normally enters
     * STOPPING state.
     * The bottom line is: set to true if you want to interrupt on-going
     * evaluations of Trials as soon as the study stopping condition is met.
     * (Please see Study.State documentation for the source of truth).
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue should_stop_asap = 1;</code>
     * @param \Google\Protobuf\BoolValue $var
     * @return $this
     */
    public function setShouldStopAsap($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\BoolValue::class);
        $this->should_stop_asap = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\BoolValue object.

     * If true, a Study enters STOPPING_ASAP whenever it would normally enters
     * STOPPING state.
     * The bottom line is: set to true if you want to interrupt on-going
     * evaluations of Trials as soon as the study stopping condition is met.
     * (Please see Study.State documentation for the source of truth).
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue should_stop_asap = 1;</code>
     * @param bool|null $var
     * @return $this
     */
    public function setShouldStopAsapUnwrapped($var)
    {
        $this->writeWrapperValue("should_stop_asap", $var);
        return $this;}

    /**
     * Each "stopping rule" in this proto specifies an "if" condition. Before
     * Vizier would generate a new suggestion, it first checks each specified
     * stopping rule, from top to bottom in this list.
     * Note that the first few rules (e.g. minimum_runtime_constraint,
     * min_num_trials) will prevent other stopping rules from being evaluated
     * until they are met. For example, setting `min_num_trials=5` and
     * `always_stop_after= 1 hour` means that the Study will ONLY stop after it
     * has 5 COMPLETED trials, even if more than an hour has passed since its
     * creation. It follows the first applicable rule (whose "if" condition is
     * satisfied) to make a stopping decision. If none of the specified rules
     * are applicable, then Vizier decides that the study should not stop.
     * If Vizier decides that the study should stop, the study enters
     * STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
     * IMPORTANT: The automatic study state transition happens precisely as
     * described above; that is, deleting trials or updating StudyConfig NEVER
     * automatically moves the study state back to ACTIVE. If you want to
     * _resume_ a Study that was stopped, 1) change the stopping conditions if
     * necessary, 2) activate the study, and then 3) ask for suggestions.
     * If the specified time or duration has not passed, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.cloud.aiplatform.v1.StudyTimeConstraint minimum_runtime_constraint = 2;</code>
     * @return \Google\Cloud\AIPlatform\V1\StudyTimeConstraint|null
     */
    public function getMinimumRuntimeConstraint()
    {
        return $this->minimum_runtime_constraint;
    }

    public function hasMinimumRuntimeConstraint()
    {
        return isset($this->minimum_runtime_constraint);
    }

    public function clearMinimumRuntimeConstraint()
    {
        unset($this->minimum_runtime_constraint);
    }

    /**
     * Each "stopping rule" in this proto specifies an "if" condition. Before
     * Vizier would generate a new suggestion, it first checks each specified
     * stopping rule, from top to bottom in this list.
     * Note that the first few rules (e.g. minimum_runtime_constraint,
     * min_num_trials) will prevent other stopping rules from being evaluated
     * until they are met. For example, setting `min_num_trials=5` and
     * `always_stop_after= 1 hour` means that the Study will ONLY stop after it
     * has 5 COMPLETED trials, even if more than an hour has passed since its
     * creation. It follows the first applicable rule (whose "if" condition is
     * satisfied) to make a stopping decision. If none of the specified rules
     * are applicable, then Vizier decides that the study should not stop.
     * If Vizier decides that the study should stop, the study enters
     * STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
     * IMPORTANT: The automatic study state transition happens precisely as
     * described above; that is, deleting trials or updating StudyConfig NEVER
     * automatically moves the study state back to ACTIVE. If you want to
     * _resume_ a Study that was stopped, 1) change the stopping conditions if
     * necessary, 2) activate the study, and then 3) ask for suggestions.
     * If the specified time or duration has not passed, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.cloud.aiplatform.v1.StudyTimeConstraint minimum_runtime_constraint = 2;</code>
     * @param \Google\Cloud\AIPlatform\V1\StudyTimeConstraint $var
     * @return $this
     */
    public function setMinimumRuntimeConstraint($var)
    {
        GPBUtil::checkMessage($var, \Google\Cloud\AIPlatform\V1\StudyTimeConstraint::class);
        $this->minimum_runtime_constraint = $var;

        return $this;
    }

    /**
     * If the specified time or duration has passed, stop the study.
     *
     * Generated from protobuf field <code>.google.cloud.aiplatform.v1.StudyTimeConstraint maximum_runtime_constraint = 3;</code>
     * @return \Google\Cloud\AIPlatform\V1\StudyTimeConstraint|null
     */
    public function getMaximumRuntimeConstraint()
    {
        return $this->maximum_runtime_constraint;
    }

    public function hasMaximumRuntimeConstraint()
    {
        return isset($this->maximum_runtime_constraint);
    }

    public function clearMaximumRuntimeConstraint()
    {
        unset($this->maximum_runtime_constraint);
    }

    /**
     * If the specified time or duration has passed, stop the study.
     *
     * Generated from protobuf field <code>.google.cloud.aiplatform.v1.StudyTimeConstraint maximum_runtime_constraint = 3;</code>
     * @param \Google\Cloud\AIPlatform\V1\StudyTimeConstraint $var
     * @return $this
     */
    public function setMaximumRuntimeConstraint($var)
    {
        GPBUtil::checkMessage($var, \Google\Cloud\AIPlatform\V1\StudyTimeConstraint::class);
        $this->maximum_runtime_constraint = $var;

        return $this;
    }

    /**
     * If there are fewer than this many COMPLETED trials, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value min_num_trials = 4;</code>
     * @return \Google\Protobuf\Int32Value|null
     */
    public function getMinNumTrials()
    {
        return $this->min_num_trials;
    }

    public function hasMinNumTrials()
    {
        return isset($this->min_num_trials);
    }

    public function clearMinNumTrials()
    {
        unset($this->min_num_trials);
    }

    /**
     * Returns the unboxed value from <code>getMinNumTrials()</code>

     * If there are fewer than this many COMPLETED trials, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value min_num_trials = 4;</code>
     * @return int|null
     */
    public function getMinNumTrialsUnwrapped()
    {
        return $this->readWrapperValue("min_num_trials");
    }

    /**
     * If there are fewer than this many COMPLETED trials, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value min_num_trials = 4;</code>
     * @param \Google\Protobuf\Int32Value $var
     * @return $this
     */
    public function setMinNumTrials($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int32Value::class);
        $this->min_num_trials = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int32Value object.

     * If there are fewer than this many COMPLETED trials, do not stop the
     * study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value min_num_trials = 4;</code>
     * @param int|null $var
     * @return $this
     */
    public function setMinNumTrialsUnwrapped($var)
    {
        $this->writeWrapperValue("min_num_trials", $var);
        return $this;}

    /**
     * If there are more than this many trials, stop the study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials = 5;</code>
     * @return \Google\Protobuf\Int32Value|null
     */
    public function getMaxNumTrials()
    {
        return $this->max_num_trials;
    }

    public function hasMaxNumTrials()
    {
        return isset($this->max_num_trials);
    }

    public function clearMaxNumTrials()
    {
        unset($this->max_num_trials);
    }

    /**
     * Returns the unboxed value from <code>getMaxNumTrials()</code>

     * If there are more than this many trials, stop the study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials = 5;</code>
     * @return int|null
     */
    public function getMaxNumTrialsUnwrapped()
    {
        return $this->readWrapperValue("max_num_trials");
    }

    /**
     * If there are more than this many trials, stop the study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials = 5;</code>
     * @param \Google\Protobuf\Int32Value $var
     * @return $this
     */
    public function setMaxNumTrials($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int32Value::class);
        $this->max_num_trials = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int32Value object.

     * If there are more than this many trials, stop the study.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials = 5;</code>
     * @param int|null $var
     * @return $this
     */
    public function setMaxNumTrialsUnwrapped($var)
    {
        $this->writeWrapperValue("max_num_trials", $var);
        return $this;}

    /**
     * If the objective value has not improved for this many consecutive
     * trials, stop the study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials_no_progress = 6;</code>
     * @return \Google\Protobuf\Int32Value|null
     */
    public function getMaxNumTrialsNoProgress()
    {
        return $this->max_num_trials_no_progress;
    }

    public function hasMaxNumTrialsNoProgress()
    {
        return isset($this->max_num_trials_no_progress);
    }

    public function clearMaxNumTrialsNoProgress()
    {
        unset($this->max_num_trials_no_progress);
    }

    /**
     * Returns the unboxed value from <code>getMaxNumTrialsNoProgress()</code>

     * If the objective value has not improved for this many consecutive
     * trials, stop the study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials_no_progress = 6;</code>
     * @return int|null
     */
    public function getMaxNumTrialsNoProgressUnwrapped()
    {
        return $this->readWrapperValue("max_num_trials_no_progress");
    }

    /**
     * If the objective value has not improved for this many consecutive
     * trials, stop the study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials_no_progress = 6;</code>
     * @param \Google\Protobuf\Int32Value $var
     * @return $this
     */
    public function setMaxNumTrialsNoProgress($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int32Value::class);
        $this->max_num_trials_no_progress = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int32Value object.

     * If the objective value has not improved for this many consecutive
     * trials, stop the study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_num_trials_no_progress = 6;</code>
     * @param int|null $var
     * @return $this
     */
    public function setMaxNumTrialsNoProgressUnwrapped($var)
    {
        $this->writeWrapperValue("max_num_trials_no_progress", $var);
        return $this;}

    /**
     * If the objective value has not improved for this much time, stop the
     * study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration max_duration_no_progress = 7;</code>
     * @return \Google\Protobuf\Duration|null
     */
    public function getMaxDurationNoProgress()
    {
        return $this->max_duration_no_progress;
    }

    public function hasMaxDurationNoProgress()
    {
        return isset($this->max_duration_no_progress);
    }

    public function clearMaxDurationNoProgress()
    {
        unset($this->max_duration_no_progress);
    }

    /**
     * If the objective value has not improved for this much time, stop the
     * study.
     * WARNING: Effective only for single-objective studies.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration max_duration_no_progress = 7;</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setMaxDurationNoProgress($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->max_duration_no_progress = $var;

        return $this;
    }

}


