<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/aiplatform/v1/study.proto

namespace Google\Cloud\AIPlatform\V1\StudySpec;

use UnexpectedValueException;

/**
 * This indicates which measurement to use if/when the service automatically
 * selects the final measurement from previously reported intermediate
 * measurements. Choose this based on two considerations:
 *  A) Do you expect your measurements to monotonically improve?
 *     If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
 *     situation where your system can "over-train" and you expect the
 *     performance to get better for a while but then start declining,
 *     choose BEST_MEASUREMENT.
 *  B) Are your measurements significantly noisy and/or irreproducible?
 *     If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
 *     may be better to choose LAST_MEASUREMENT.
 *  If both or neither of (A) and (B) apply, it doesn't matter which
 *  selection type is chosen.
 *
 * Protobuf type <code>google.cloud.aiplatform.v1.StudySpec.MeasurementSelectionType</code>
 */
class MeasurementSelectionType
{
    /**
     * Will be treated as LAST_MEASUREMENT.
     *
     * Generated from protobuf enum <code>MEASUREMENT_SELECTION_TYPE_UNSPECIFIED = 0;</code>
     */
    const MEASUREMENT_SELECTION_TYPE_UNSPECIFIED = 0;
    /**
     * Use the last measurement reported.
     *
     * Generated from protobuf enum <code>LAST_MEASUREMENT = 1;</code>
     */
    const LAST_MEASUREMENT = 1;
    /**
     * Use the best measurement reported.
     *
     * Generated from protobuf enum <code>BEST_MEASUREMENT = 2;</code>
     */
    const BEST_MEASUREMENT = 2;

    private static $valueToName = [
        self::MEASUREMENT_SELECTION_TYPE_UNSPECIFIED => 'MEASUREMENT_SELECTION_TYPE_UNSPECIFIED',
        self::LAST_MEASUREMENT => 'LAST_MEASUREMENT',
        self::BEST_MEASUREMENT => 'BEST_MEASUREMENT',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}


